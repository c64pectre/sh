;    sh: Shell for Commodore 64.
;    Copyright (C) 2026  C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/exehdr/ create an issue

;region Kernal internal

    KERNAL_NNMI20 := $FE72                                      ; Kernal nnmi20 continuation of NMI handing.

    ;endregion

;
;region Memory areas

    ; Area 1: $0200-$0258 89 bytes
    AREA_1      := KVAR_BUF_BUFOFS
    AREA_1_LAST := KVAR_BUF_BUFOFS_LAST
    AREA_1_SIZE =  KVAR_BUF_BUFOFS_SIZE

    ; Area 2: $02A7-$02FF 89 bytes
    AREA_2      := KVAR_UNUSED_1
    AREA_2_LAST := KVAR_UNUSED_1_LAST
    AREA_2_SIZE =  KVAR_UNUSED_1_SIZE

    ; Area 3: $0334-$033B 8 bytes
    AREA_3      := KVAR_UNUSED_2
    AREA_3_LAST := KVAR_UNUSED_2_LAST
    AREA_3_SIZE =  KVAR_UNUSED_2_SIZE

    ; Area 4: $033C-$03FF 196 bytes
    AREA_4      := KERNAL_TBUFFR
    AREA_4_LAST := KVAR_UNUSED_3_LAST
    AREA_4_SIZE =  < AREA_4_LAST - AREA_4 + 1

    ;endregion

;
;region Memory layout

    FILE_NAME_TEXT       := AREA_1
    FILE_NAME_TEXT_DRIVE := FILE_NAME_TEXT + 0
    FILE_NAME_TEXT_COLON := FILE_NAME_TEXT + 1

    DISK_STATUS_TEXT        := AREA_1
    DISK_STATUS_TEXT_CODE_0 := DISK_STATUS_TEXT + 0
    DISK_STATUS_TEXT_CODE_1 := DISK_STATUS_TEXT + 1

    DISK_COMMAND_TEXT := AREA_1

    BUFFERED_OUT_BUFFER      := AREA_2
    BUFFERED_OUT_BUFFER_LAST := AREA_2_LAST
    BUFFERED_OUT_BUFFER_SIZE =  AREA_2_SIZE

    SYS_DEVICE             := AREA_3 + 0 ; $0334 ; $17FA
    SYS_DRIVE              := AREA_3 + 1 ; $0335 ; $17FB
    WORK_DEVICE            := AREA_3 + 2 ; $0336 ; $17FC
    WORK_DRIVE             := AREA_3 + 3 ; $0337 ; $17FD
    REDIRECT_INPUT_ACTIVE  := AREA_3 + 4 ; $0338 ; $17FE ; 0 = no , 1 = yes
    REDIRECT_OUTPUT_ACTIVE := AREA_3 + 5 ; $033A ; $17FF ; 0 = no , 1 = yes
    AREA_3_UNUSED_6        := AREA_3 + 6 ; $0339
    AREA_3_UNUSED_7        := AREA_3 + 7 ; $033B

    ; ARGC: Argument count
    ARGC    := AREA_4 + 0 ; $033C
    ARGC_LO := ARGC       ; $033C
    ARGC_HI := ARGC + 1   ; $033D

    ; PARGV: Pointer to argv: argument value array: array of pointer to string
    PARGV    := AREA_4 + 2 ; $033E
    PARGV_LO := PARGV      ; $033E
    PARGV_HI := PARGV + 1  ; $033F

    ARGV      := AREA_4 + 4 ; $0340
    ARGV_0    := ARGV + 0   ; $0340
    ARGV_0_LO := ARGV_0     ; $0340
    ARGV_0_HI := ARGV_0 + 1 ; $0341
    ARGV_1    := ARGV + 2   ; $0342
    ARGV_1_LO := ARGV_1     ; $0342
    ARGV_1_HI := ARGV_1 + 1 ; $0343
    ARGV_2    := ARGV + 4   ; $0344
    ARGV_2_LO := ARGV_2     ; $0344
    ARGV_2_HI := ARGV_2 + 1 ; $0345
    ARGV_3    := ARGV + 6   ; $0346
    ARGV_3_LO := ARGV_3     ; $0346
    ARGV_3_HI := ARGV_3 + 1 ; $0347
    ARGV_4    := ARGV + 8   ; $0348
    ARGV_4_LO := ARGV_4     ; $0348
    ARGV_4_HI := ARGV_4 + 1 ; $0349
    ARGV_5    := ARGV + 10  ; $034A
    ARGV_5_LO := ARGV_5     ; $034A
    ARGV_5_HI := ARGV_5 + 1 ; $034B
    ARGV_6    := ARGV + 12  ; $034C
    ARGV_6_LO := ARGV_6     ; $034C
    ARGV_6_HI := ARGV_6 + 1 ; $034D
    ARGV_7    := ARGV + 14  ; $034E
    ARGV_7_LO := ARGV_7     ; $034E
    ARGV_7_HI := ARGV_7 + 1 ; $034F
    ARGV_8    := ARGV + 16  ; $0350
    ARGV_8_LO := ARGV_8     ; $0350
    ARGV_8_HI := ARGV_8 + 1 ; $0351
    ARGV_9    := ARGV + 18  ; $0352
    ARGV_9_LO := ARGV_9     ; $0352
    ARGV_9_HI := ARGV_9 + 1 ; $0353

    ;;; summary: Input text $0354-03A5 (82 bytes)
    INPUT_TEXT                      := $0354
    INPUT_TEXT_SIZE                 =  82
    INPUT_TEXT_LAST                 := INPUT_TEXT + INPUT_TEXT_SIZE

    ;;; summary: Name of loaded program, if any (then LOADED_PROGRAM_NAME[0] == 0) $03A6-$03B4 (14 bytes)
    LOADED_PROGRAM_NAME             := $03A6
    LOADED_PROGRAM_NAME_SIZE        = COMMAND_NAME_MAX_LENGTH + 1
    LOADED_PROGRAM_NAME_LAST        := LOADED_PROGRAM_NAME + LOADED_PROGRAM_NAME_SIZE
    ; Save colors
    SAVE_KVAR_COLOR                 := $03B5
    SAVE_VIC_EC                     := $03B6
    SAVE_VIC_B0C                    := $03B7
    ; NMI
    SAVE_KERNAL_NMINV_LO            := $03B8
    SAVE_KERNAL_NMINV_HI            := $03B9
    SAVE_S                          := $03BA
    NMI_ENTRY_COUNT                 := $03BB
    ; CMD_DIR, IN_BYTE
    SAVE_KERNAL_READST              := $03BC
    ; BINARY_TO_DECIMAL
    BINARY_TO_DECIMAL_BINARY_LO     := $03BD
    BINARY_TO_DECIMAL_BINARY_HI     := $03BE
    BINARY_TO_DECIMAL_TMP           := $03BF
    BINARY_TO_DECIMAL_DECIMAL_DIGIT := $03C0
    BINARY_TO_DECIMAL_DECIMAL       := $03C1
    BINARY_TO_DECIMAL_DECIMAL_0     := $03C2
    BINARY_TO_DECIMAL_DECIMAL_1     := $03C3
    BINARY_TO_DECIMAL_DECIMAL_2     := $03C4
    BINARY_TO_DECIMAL_DECIMAL_3     := $03C5
    ; BUFFERED_OUT
    BUFFERED_OUT_SAVE_X             := $03C6
    BUFFERED_OUT_CURSOR             := $03C7

    ; 40 bytes available
    AREA_3_AVAILABLE_FIRST := $03C8
    AREA_3_AVAILABLE_LAST  := $03FF

    ;endregion

;
;region Main

    ;;; summary: Main
    .proc MAIN
        jsr INITIALIZE
        jsr RUN

        rts
    .endproc

    ;endregion

;
;region Implementation

    ;;; summary: Initialize
    .proc INITIALIZE
        ; Save stack pointer
        tsx
        stx SAVE_S

        ; Set border color
        lda CONFIG_BORDER_COLOR
        if_pl_then
            sta VIC_EC
        else_end

        ; Set background color
        lda CONFIG_BACKGROUND_COLOR
        if_pl_then
            sta VIC_B0C
        else_end

        ; Set foreground color
        lda CONFIG_FOREGROUND_COLOR_CHAR
        if_ne_then
            jsr KERNAL_CHROUT
        else_end

        ; Clear screen
        lda # PETSCII_CLR
        jsr KERNAL_CHROUT

        ; Set system and work device to default device (8)
        lda # DEFAULT_DEVICE
        sta SYS_DEVICE
        sta WORK_DEVICE

        ; Set to device number of current file, if any
        lda ZPKERNAL_FA
        if_ne_then
            sta SYS_DEVICE
            sta WORK_DEVICE
        else_end

        ; Set system and work drive to 0, i.e. single side, or upper side of double sided drive.
        lda # DEFAULT_DRIVE
        sta SYS_DRIVE
        sta WORK_DRIVE

        ; PARGV = &ARGV
        lda # <ARGV
        sta PARGV_LO
        lda # >ARGV
        sta PARGV_HI

        lda # 0
        ; ARGC = 0. Note: ARGC_HI is always 0 because ARGC_MAX = 10
        sta ARGC_LO
        sta ARGC_HI

        ; Reset NMI entry count
        sta NMI_ENTRY_COUNT                                     ; NMI_ENTRY_COUNT = 0

        ; Redirect input & output inactive
        sta REDIRECT_INPUT_ACTIVE                               
        sta REDIRECT_OUTPUT_ACTIVE

        ; Set no program loaded
        sta LOADED_PROGRAM_NAME

        ; Save NMI handler
        lda KERNAL_NMINV_LO
        sta SAVE_KERNAL_NMINV_LO
        lda KERNAL_NMINV_HI
        sta SAVE_KERNAL_NMINV_HI

        ; Set our NMI handler
        lda # <MY_NMI_HANDLER
        sta KERNAL_NMINV_LO
        lda # >MY_NMI_HANDLER
        sta KERNAL_NMINV_HI

        rts
    .endproc

    ;;; summary: Run loop
    .proc RUN
        lda # PETSCII_SHIFTED_MODE
        jsr KERNAL_CHROUT

        from_loop
            jsr SHOW_PROMPT
            jsr IN_READ_LINE_TO_INPUT_TEXT
            jsr PROCESS_INPUT_TEXT
        next
            jmp _loop
        end

        ; Does not come here
    .endproc

    ;;; summary: Show prompt
    .proc SHOW_PROMPT
        lda # PETSCII_DOLLAR
        jsr KERNAL_CHROUT
        lda # PETSCII_SPACE
        jsr KERNAL_CHROUT

        rts
    .endproc

    ;;; summary: Read line from input (presumably keyboard)
    ;;; out:
    ;;;   INPUT_TEXT: One line of text, PETSCII_RETURN replaced with PETSCII_NUL.
    .proc IN_READ_LINE_TO_INPUT_TEXT
        from
            ldy # 0
        loop
            jsr KERNAL_CHRIN                                    ; A+ X+ Y-
            cmp # PETSCII_RETURN
            beq _end                                            ; break
            sta INPUT_TEXT,y
        next
            iny
            bne _loop
        end
        
        jsr KERNAL_CHROUT
        lda # PETSCII_NUL
        sta INPUT_TEXT,y

        rts
    .endproc

    ;;; summary: Process input text
    ;;; in:
    ;;;   INPUT_TEXT: Input text, nul terminated
    ;;; changed: A+ X+ Y+
    .proc PROCESS_INPUT_TEXT
        ; Y: Pointer in ARGV
        ldy # 0
        sty ARGC_LO
        sty REDIRECT_INPUT_ACTIVE                               ; Redirect input inactive
        sty REDIRECT_OUTPUT_ACTIVE                              ; Redirect output inactive

        ; X: cursor in INPUT_TEXT.
        from OUTER
            ldx # $FF                                           ; -1
        loop
            ; Skip any SPACE and NO_BREAK_SPACE
            inx
            lda INPUT_TEXT,x
            if_eq_then
                jmp OUTER::_end                                ; break
            else_end

            ; Skip any space or no-break space    
            cmp # PETSCII_SPACE
            beq OUTER::_loop
            cmp # PETSCII_NO_BREAK_SPACE
            beq OUTER::_loop
                
            ; Redirect input from file?
            cmp # PETSCII_LESS_THAN_SIGN
            if_eq_then
                ; Yes
                jsr REDIRECT_INPUT_FROM_FILE                    ; 
                bcc OUTER::_loop                                ; OK -> continue

                ; Error redirecting input from file
                jsr ERROR_CANT_OPEN_INPUT_FILE
                rts
            else_end

            ; Redirect output to file or printer?
            cmp # PETSCII_GREATER_THAN_SIGN
            if_eq_then
                inx
                lda INPUT_TEXT,x
                cmp # PETSCII_GREATER_THAN_SIGN
                if_eq_then
                    ; Redirect output to printer
                    jsr REDIRECT_OUTPUT_TO_PRINTER
                    bcc OUTER::_loop                            ; OK -> continue

                    ; Error redirecting output to printer
                    jsr ERROR_PRINTER_NOT_PRESENT
                    rts
                else_end

                ; Redirect output to file
                dex
                jsr REDIRECT_OUTPUT_TO_FILE
                bcc OUTER::_loop                                ; OK -> continue

                ; Error redirecting output to file
                jsr ERROR_CANT_OPEN_OUTPUT_FILE
                rts
            else_end

            ; We have the start of an argument.
            inc ARGC_LO
            ; Quoted argument?
            cmp # PETSCII_QUOTATION_MARK
            if_eq_then
                ; Yes
                inx
                jsr SET_NEXT_ARGV
                dex

                from_loop
                    inx
                    lda INPUT_TEXT,x
                    beq OUTER::_end                             ; EOI -> break
                next
                    ; Closing quotation mark?
                    cmp # PETSCII_QUOTATION_MARK
                    bne _loop
                end

                ; Found closing quotation mark
                lda # PETSCII_NUL
                sta INPUT_TEXT,x
                jmp OUTER::_loop                                ; continue
            else_end

            jsr SET_NEXT_ARGV

            from_loop INNER
                inx
                lda INPUT_TEXT,x
                beq OUTER::_end                                 ; EOI -> break
                cmp # PETSCII_SPACE
                beq INNER::_END                                 ; break
            next
                cmp # PETSCII_NO_BREAK_SPACE
                bne INNER::_loop
            end

            lda # PETSCII_NUL
            sta INPUT_TEXT,x
        next
            jmp _loop
        end

        ; Finished parsing input text
        ; Have we got any arguments?
        lda ARGC_LO
        if_ne_then
            ; We have got arguments
            ; BX := ARGV[0]
            lda ARGV_0_LO
            sta BL
            lda ARGV_0_HI
            sta BH
            ldy # 0
            lda [BX],y
            ; Argument 0 not empty?
            if_ne_then
                jsr TRY_BUILT_IN_COMMAND
                if_cs_then                                      ; Not built-in command
                    jsr LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
                    if_cc_then
                        jsr EXECUTE_PROGRAM
                    else_end
                else_end
            else_end
        else_end

        jsr RESET_FILE_IO

        rts
    .endproc

    ;;; summary: Try built-in command
    ;;; in: 
    .proc TRY_BUILT_IN_COMMAND
        jsr MAP_COMMAND_NAME_TO_COMMAND_NUMBER                  ; X = command number if Z=1
        if_ne_then
            sec                                                 ; Not built-in command
            rts
        else_end

        lda TABLE_COMMAND_HANDLER_LO,x
        sta DL
        lda TABLE_COMMAND_HANDLER_HI,x
        sta DH
        jsr JSR_INDIRECT_DX
        clc
        rts
    .endproc

    ;;; summary: Load program with, if not already done so.
    ;;; in:
    ;;;   BX: Name of program to load.
    ;;; out:
    ;;;   C: 0=OK 1=FAIL
    ;;; changed: A+ X? Y? AX+
    .proc LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
        lda # <LOADED_PROGRAM_NAME
        sta AL
        lda # >LOADED_PROGRAM_NAME
        sta AH
        jsr STRING_COMPARE
        if_eq_then
            clc                                                 ; OK

            rts
        else_end

        jsr LOAD_PROGRAM_FROM_WORK_OR_SYS_DISK
        rts
    .endproc

    ;;; summary: Load program from work disk or else from system disk
    ;;; in:
    ;;;   BX: Name of program to load.
    ;;; out:
    ;;;   C: 0=OK 1=FAIL
    .proc LOAD_PROGRAM_FROM_WORK_OR_SYS_DISK
        ; Try work disk
        ldx WORK_DEVICE
        ldy WORK_DRIVE
        jsr LOAD_PROGRAM
        if_cs_then
            ; Load from work disk failed.
            ; Try system disk
            ldx SYS_DEVICE
            ldy SYS_DRIVE
            jsr LOAD_PROGRAM
            if_cs_then
                ; Load from system disk failed too.
                jsr ERROR_COMMAND_NOT_FOUND
                sec                                             ; FAIL

                rts
            else_end
        else_end

        ; Save name of loaded program.
        ; notes: We know program name is max 16 characters + 1 for nul
        from
            ldy # 0
        loop
            lda [BX],y
            sta LOADED_PROGRAM_NAME,y
        next
            iny
            cmp # PETSCII_NUL
            bne _loop
        end
        clc                                                     ; OK

        rts
    .endproc

    ;;; summary: Execute loaded program
    ;;; notes:
    ;;;   Entry point is at $1800
    ;;; changed: A+ X+ Y+ AX
    .proc EXECUTE_PROGRAM
        ; Save colors
        lda KVAR_COLOR
        sta SAVE_KVAR_COLOR
        lda VIC_EC
        sta SAVE_VIC_EC
        lda VIC_B0C
        sta SAVE_VIC_B0C

        ; Call program's entrypoint
        jsr PROGRAM_ENTRYPOINT

        ; Restore colors
        lda SAVE_VIC_EC
        sta VIC_EC
        lda SAVE_VIC_B0C
        sta VIC_B0C
        lda SAVE_KVAR_COLOR
        sta KVAR_COLOR
        ; Set all character color
        from OUTER
            ldx # >SCREEN_COLOR_RAM_BASE
            ldy # <SCREEN_COLOR_RAM_BASE
            sty AL
        loop
            from INNER
                stx AH
            loop
                sta [AX],y
            next
                iny
                bne _loop
            end
        next
            inx
            cpx # SCREEN_COLOR_RAM_PAGE_LAST + 1
            bne OUTER::_loop
        end

        rts
    .endproc

    ;;; summary: Back to default file I/O
    ;;; changed: A+ X+ Y+ AL+
    .proc RESET_FILE_IO
        ldx ZPKERNAL_LDTND
        dex
        if_pl_then
            from
                stx AL
            loop
                ldx AL
                lda KVAR_LAT,x
                jsr KERNAL_CLOSE                                ; A+ X+ Y+
            next
                dec AL
                bpl _loop
            end
        else_end

        jsr KERNAL_CLRCHN

        ; Redirect input & output inactive
        lda # 0
        sta REDIRECT_INPUT_ACTIVE
        sta REDIRECT_OUTPUT_ACTIVE

        rts
    .endproc

    ;;; summary: Load program
    ;;; in:
    ;;;   X: Device Address (DA)
    ;;;   Y: Drive Number (DN)
    ;;;   BX:   File name
    ;;; changed: A+ X+ Y+ AL+
    .proc LOAD_PROGRAM
        stx AL                                              ; AL = X = DA   
        tya
        clc
        adc # PETSCII_DIGIT_ZERO
        sta FILE_NAME_TEXT_DRIVE
        lda # PETSCII_COLON
        sta FILE_NAME_TEXT_COLON
        from
            ldy # 0
            ldx # FILE_NAME_TEXT_COLON_OFFSET_NAME          ; 2
        loop
            lda [BX],y
            beq _end                                        ; NUL -> break
            sta  FILE_NAME_TEXT,x
        next
            iny
            inx
            bne _loop
        end
    
        ; Add ".sh"
        lda # PETSCII_FULL_STOP
        sta FILE_NAME_TEXT,x
        inx
        lda # PETSCII_LATIN_LETTER_S
        sta FILE_NAME_TEXT,x
        inx
        lda # PETSCII_LATIN_LETTER_H
        sta FILE_NAME_TEXT,x
        inx                                                 ; X = FILE_NAME_TEXT.LENGTH
        txa                                                 ; A = X = FILE_NAME_TEXT.LENGTH
        ldx # <FILE_NAME_TEXT
        ldy # >FILE_NAME_TEXT

        jsr KERNAL_SETNAM
        ldx AL                                              ; X = AL = DA
        lda # FILE_FA                                       ; A = FILE_FA = FILE_SA
        tay                                                 ; Y = FILE_SA
        jsr KERNAL_SETLFS
        lda # KERNAL_LOAD_LOAD
        jsr KERNAL_LOAD
        if_cc_then
            rts                                             ; OK
        else_end

        ; Load error
        cmp # KERNAL_ERROR_DEVICE_NOT_PRESENT
        if_eq_then
            ; Device not present
            sec
            rts
        else_end

        ; Device present. (Attempt to) read (but not show) disk status.
        lda # DISK_COMMAND_FA                               ; DISK_COMMAND_FA = DISK_COMMAND_SA
        ldx AL                                              ; X = AL = DA
        tay
        jsr KERNAL_SETLFS
        lda # 0                                             ; No name
        jsr KERNAL_SETNAM
        jsr KERNAL_OPEN
        if_cc_then
            ldx # DISK_COMMAND_FA
            jsr KERNAL_CHKIN
            if_cc_then
                from_loop
                    jsr KERNAL_CHRIN
                next
                    cmp # PETSCII_RETURN
                    bne _loop
                end
            else_end
        else_end

        lda # DISK_COMMAND_FA
        jsr KERNAL_CLOSE
        jsr KERNAL_CLRCHN
        sec                                                 ; FAIL

        rts
    .endproc

    ;;; summary: Set next argv from input text `INPUT_TEXT` at position `X`.
    ;;; in:
    ;;;   X: Position in INPUT_TEXT
    ;;; out:
    ;;;   ARGV[Y']: = < INPUT_TEXT
    ;;;   ARGV[Y'+1]: = > INPUT_TEXT
    ;;;   Y: = Y' + 2
    ;;; changed:
    ;;;   ARGV[]
    ;;;   A+ X- Y+
    .proc SET_NEXT_ARGV
        clc
        txa
        adc # <INPUT_TEXT
        sta ARGV,y
        iny
        lda # 0
        adc # >INPUT_TEXT
        sta ARGV,y
        iny

        rts
    .endproc

    ;;; summary: redirect input from file named `FILE_NAME_TEXT` extracted from `INPUT_TEXT` on work disk
    ;;; in:
    ;;;   INPUT_TEXT: Input text
    ;;;   Y:
    ;;; out:
    ;;;   REDIRECT_INPUT_ACTIVE: Set to 1: redirect input active
    ;;;   C: 0=OK 1=FAIL
    ;;; changed: A+ X- Y+ BX+
    ;;; notes: Need to preserve X & Y for PROCESS_INPUT_TEXT
    .proc REDIRECT_INPUT_FROM_FILE
        sty BH
            lda # 1
            sta REDIRECT_INPUT_ACTIVE
            jsr GET_FILE_NAME_FROM_INPUT_TEXT_FOR_WORK_DRIVE    ; A+ X+ Y=FILE_NAME_TEXT.LENGTH
            if_cs_then
                rts                                             ; Caller (PROCESS_INPUT_TEXT) cancels further processing, so no need to restore Y.
            else_end

            stx BL
                tya
                ldx # <FILE_NAME_TEXT
                ldy # >FILE_NAME_TEXT
                jsr KERNAL_SETNAM
                lda # REDIRECT_INPUT_FA
                ldx WORK_DEVICE
                ldy # REDIRECT_INPUT_SA
                jsr KERNAL_SETLFS
                jsr KERNAL_OPEN
                if_cs_then
                    rts                                             ; Caller (PROCESS_INPUT_TEXT) cancels further processing, so no need to restore X & Y.
                else_end

                lda WORK_DEVICE
                jsr PROCESS_DISK_STATUS
            ldx BL
        ldy BH

        rts
    .endproc

    ;;; summary: Redirect output to file named `FILE_NAME_TEXT` extracted from `INPUT_TEXT` on work disk
    ;;; changed: A+ X- Y- BX+
    ;;; notes: Need to preserve X & Y for PROCESS_INPUT_TEXT
    .proc REDIRECT_OUTPUT_TO_FILE
        sty BH
            lda # 1
            sta REDIRECT_OUTPUT_ACTIVE
            jsr GET_FILE_NAME_FROM_INPUT_TEXT_FOR_WORK_DRIVE    ; A+ X+ / X=Position in FILE_NAME_TEXT / Y=FILE_NAME_TEXT.LENGTH
            if_cs_then
                ; FAIL
                rts                                             ; Caller (PROCESS_INPUT_TEXT) cancels further processing, so no need to restore Y.
            else_end

            stx BL
                dey
                dey
                lda FILE_NAME_TEXT,y
                iny
                iny
                cmp # PETSCII_COMMA
                if_ne_then
                    lda # PETSCII_COMMA
                    sta FILE_NAME_TEXT,y
                    iny
                    lda # PETSCII_LATIN_LETTER_S
                    sta FILE_NAME_TEXT,y
                    iny
                else_end

                lda # PETSCII_COMMA
                sta FILE_NAME_TEXT,y
                iny
                lda # PETSCII_LATIN_LETTER_W
                sta FILE_NAME_TEXT,y
                iny
                tya
                ldx # <FILE_NAME_TEXT
                ldy # >FILE_NAME_TEXT
                jsr KERNAL_SETNAM                               ; A=NAME.LENGTH X=<NAME Y=>NAME
                lda # REDIRECT_OUTPUT_FA
                ldx WORK_DEVICE
                ldy # REDIRECT_OUTPUT_FILE_SA
                jsr KERNAL_SETLFS                               ; A=FA X=DA Y=SA
                jsr KERNAL_OPEN
                if_cs_then
                    ; FAIL
                    rts                                         ; Caller (PROCESS_INPUT_TEXT) cancels further processing, so no need to restore  X & Y.
                else_end

                lda WORK_DEVICE
                jsr PROCESS_DISK_STATUS
            ldx BL
        ldy BH

        rts
    .endproc

    ;;; summary: Read disk status of device `A` into `DISK_STATUS_TEXT`, printing if not equal to "00"
    ;;; in:
    ;;;   A: Device Address (DA)
    ;;; out:
    ;;;   DISK_STATUS_TEXT: Disk status that has been read
    ;;;   C: 0=OK 1=FAIL
    ;;; changed: A+ X+ Y+
    .proc PROCESS_DISK_STATUS
        pha
            lda # 0
            jsr KERNAL_SETNAM                                   ; No name
        pla
        tax                                                     ; X = A' = DA
        lda # DISK_COMMAND_FA                                   ; A = DISK_COMMAND_FA = DISK_COMMAND_SA
        tay                                                     ; Y = DISK_COMMAND_SA
        jsr KERNAL_SETLFS                                       ; A=FA X=DA Y=SA
        jsr KERNAL_OPEN
        ldx # DISK_COMMAND_FA
        jsr KERNAL_CHKIN
        from
            ldy # 0
        loop
            jsr KERNAL_CHRIN
            sta DISK_STATUS_TEXT,y
            iny
        next
            cmp # PETSCII_RETURN
            bne _loop
        end

        jsr KERNAL_CLRCHN

        if
            lda DISK_STATUS_TEXT_CODE_0
            cmp # PETSCII_DIGIT_ZERO
            bne _then
            lda DISK_STATUS_TEXT_CODE_1
            cmp # PETSCII_DIGIT_ZERO
            beq _else
        then
            ; ! (DISK_STATUS_TEXT_CODE_0 = "0" & DISK_STATUS_TEXT_CODE_1 = "0")
            ; Error
            jsr OUT_DISK_STATUS_TEXT
            sec
            bcs _end                                            ; bra
        else
            ; OK
            clc
        end

        rts
    .endproc

    ;;; summary: Print disk status text to output (presumably screen)
    .proc OUT_DISK_STATUS_TEXT
        from
            ldy # 0
        loop
            lda DISK_STATUS_TEXT,y
            cmp # PETSCII_RETURN
            beq _end                                            ; break
            jsr KERNAL_CHROUT
        next
            iny
            bne _loop                                           ; bra
        L103E:
        end

        ; Print the RETURN too    
        jsr KERNAL_CHROUT

        rts
    .endproc

    ;;; summary: Get (extract) file name from `INPUT_TEXT` from position `X`, prefixed with work drive and colon.
    ;;; in:
    ;;;   INPUT_TEXT: Input text
    ;;;   X: Starting position
    ;;; out:
    ;;;   FILE_NAME_TEXT: Extracted file name, prefixed with work drive and colon
    ;;;   X: Position of last character of extracted file name in `INPUT_TEXT`
    ;;;   Y: FILE_NAME_TEXT.LENGTH
    ;;;   C: 0=OK 1=FAIL
    ;;; changed: A+ X+ Y+
    ;;; notes:
    ;;;   TODO Quoted file name is not possible
    .proc GET_FILE_NAME_FROM_INPUT_TEXT_FOR_WORK_DRIVE
        ; Skip any space and no-break space
        from_loop
            inx
            lda INPUT_TEXT,x
            if_eq_then
                ; Empty string
                sec                                             ; FAIL
                rts
            else_end
        next
            cmp # PETSCII_SPACE
            beq _loop                                           ; continue
            cmp # PETSCII_NO_BREAK_SPACE
            beq _loop
        end

        clc
        lda WORK_DRIVE
        adc # PETSCII_DIGIT_ZERO
        sta FILE_NAME_TEXT_DRIVE                                ; FILE_NAME[0] := WORK_DEVICE.TO_DECIMAL_CHAR
        lda # PETSCII_COLON
        sta FILE_NAME_TEXT_COLON                                ; FILE_NAME[1] := ":"

        from
            ldy # 2
        loop
            lda INPUT_TEXT,x
            beq _end                                            ; break
            cmp # PETSCII_SPACE
            beq _end                                            ; break
            cmp # PETSCII_NO_BREAK_SPACE
            beq _end
            sta FILE_NAME_TEXT,y
        next
            iny
            inx
            bne _loop                                           ; bra
        end

        dex
        clc                                                     ; OK

        rts
    .endproc

    ;;; summary: Redirect output to printer (device 4)
    ;;; out:
    ;;;   C: 0=OK 1=FAIL
    ;;; changed: A+ X- Y- BX+
    ;;; notes: Need to preserve X & Y for PROCESS_INPUT_TEXT
    .proc REDIRECT_OUTPUT_TO_PRINTER
        stx BL
        sty BH
            lda # 1
            sta REDIRECT_OUTPUT_ACTIVE

            lda # REDIRECT_OUTPUT_FA
            ldx # REDIRECT_OUTPUT_PRINTER_DA
            ldy # REDIRECT_OUTPUT_PRINTER_SA
            jsr KERNAL_SETLFS
            lda # 0                                                 ; No name
            jsr KERNAL_SETNAM
            jsr KERNAL_OPEN
            if_cc_then
                ldx # REDIRECT_OUTPUT_FA
                jsr KERNAL_CHKOUT
            else_end

            php
                jsr KERNAL_CLRCHN
            plp
        ldy BH
        ldx BL

        rts
    .endproc

;
;region Build-in commands

    .proc CMD_EXIT
        jsr RESET_FILE_IO
        lda SAVE_KERNAL_NMINV_LO
        sta KERNAL_NMINV_LO
        lda SAVE_KERNAL_NMINV_HI
        sta KERNAL_NMINV_HI
        ldx SAVE_S
        txs
        rts
    .endproc

    ;;; summary: Load program
    ;;; in:
    ;;;   ARGV[1]: Program name
    .proc CMD_LOAD
        lda ARGC_LO
        cmp # 2
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS

            rts
        else_end

        lda ARGV_1_LO
        sta BL
        lda ARGV_1_HI
        sta BH
        jsr LOAD_PROGRAM_IF_NOT_ALREADY_LOADED

        rts
    .endproc

    .proc CMD_LS
        ldx SYS_DEVICE
        ldy SYS_DRIVE
        jsr CMD_DIR
        rts
    .endproc

    .proc CMD_L
        ldx WORK_DEVICE
        ldy WORK_DRIVE
        jsr CMD_DIR
        rts
    .endproc

    ;;; summary: Command: directory listing of work or system disk
    ;;; in:
    ;;;   X: Device address (8-31) DA
    ;;;   Y: Drive number (0-1) DN
    ;;; changed: A+ X+ Y+ AX+ BX+
    .proc CMD_DIR
        stx BL                                                  ; BL = DA
        sty BH                                                  ; BH = DN

        lda # PETSCII_DOLLAR
        sta DISK_COMMAND_TEXT + 0

       ;txa                                                     ; A = X = DA
       ;pha                                                     ; STACK = [DA]...
       ;    tya                                                 ; A = Y = [DN]
       lda BH                                                   ; A = BH = DN
            clc
            adc # PETSCII_DIGIT_ZERO
            sta DISK_COMMAND_TEXT + 1

            ldx # 2
            lda ARGC_LO
            cmp # 2
            if_eq_then
                lda # PETSCII_COLON
                sta DISK_COMMAND_TEXT,x
                inx
                from
                    lda ARGV_1_LO
                    sta AL
                    lda ARGV_1_HI
                    sta AH
                    ldy # 0
                loop
                    lda [AX],y
                    beq _end                                    ; break
                    sta DISK_COMMAND_TEXT,x
                next
                    iny
                    inx
                    bne _loop                                   ; bra
                end

                jmp _end
            else
                cmp # 1
                if_ne_then
                    pla
                    jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
                    rts
                else_end
            end

            txa                                                 ; A = DIR_NAME_DOLLAR.LENGTH
            ldx # <DISK_COMMAND_TEXT
            ldy # >DISK_COMMAND_TEXT
            jsr KERNAL_SETNAM
       ;pla                                                     ; A = DA , STACK = ...
       ;pha                                                     ; A = DA , STACK = [DA]...
       ;    tax
        ldx BL                                                  ; X = BL = DA
            lda # FILE_FA
            ldy # 0
            jsr KERNAL_SETLFS
            jsr KERNAL_OPEN
            if_cs_then
                pla
                jsr ERROR_DEVICE_NOT_PRESENT
                rts
            else_end
       ;pla                                                     ; A = DA , STACK = ...
        lda BL                                                  ; A = BL = DA
        jsr PROCESS_DISK_STATUS
        if_cs_then
            rts
        else_end

        jsr BUFFERED_OUT_INIT
        ldx # FILE_FA
        jsr KERNAL_CHKIN
        jsr KERNAL_CHRIN
        jsr KERNAL_CHRIN
        lda # PETSCII_RETURN
        jsr BUFFERED_OUT_BYTE
        ; Clear serial status
        lda # KERNAL_OK                                     ; 0
        sta SAVE_KERNAL_READST

        from_loop OUTER
            jsr IN_BYTE
            bcs _end                                        ; break
            jsr IN_BYTE
            bcs _end                                        ; break
            jsr IN_BYTE
            bcs _end                                        ; break
            pha
                jsr IN_BYTE
                tay
            pla
            tax
            jsr BINARY_TO_DECIMAL

            from
                ldx # 0
            loop
                lda BINARY_TO_DECIMAL_DECIMAL,x
                cmp # PETSCII_SPACE
                beq _end                                        ; break
                jsr BUFFERED_OUT_BYTE
            next
                inx
                cpx # 3
                bne _loop
            end

            lda # PETSCII_SPACE
            jsr BUFFERED_OUT_BYTE

            from_loop
                jsr IN_BYTE
                bcs OUTER::_end                                 ; break OUTER
                cmp # PETSCII_NUL
                beq _end                                        ; break
                jsr BUFFERED_OUT_BYTE
            next
                jmp _loop
            end

            lda # PETSCII_RETURN
            jsr BUFFERED_OUT_BYTE

            ; Pause on SHIFT
            from_loop
                lda ZPKERNAL_SFDX                               ; $CB Matrix code of key currently being pressed. Values: $00-$3F: Keyboard matrix code. $40: No key is currently pressed. 
                eor # $40
                ora KVAR_SHFLAG                                 ; $028D Shift key indicator. Bits: Bit #0: 1 = One or more of left Shift, right Shift or Shift Lock is currently being pressed or locked. Bit #1: 1 = Commodore is currently being pressed. Bit #2: 1 = Control is currently being pressed.
            next
                bne _loop
            end

        next
            jmp _loop
        end

        lda # PETSCII_RETURN
        jsr BUFFERED_OUT_BYTE
        jsr BUFFERED_OUT_FLUSH

        lda # FILE_FA
        jsr KERNAL_CLOSE

        rts
    .endproc

    ;;; summary: Send command to work disk
    ;;; changed: A+ X+ Y+ AX
    .proc CMD_DISK
        lda ARGC_LO
        cmp # 2
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS

            rts
        else_end

        lda ARGV_1_LO
        sta AL
        lda ARGV_1_HI
        sta AH
        lda # DISK_COMMAND_FA                                   ; DISK_COMMAND_FA = DISK_COMMAND_SA
        ldx WORK_DEVICE
        tay
        jsr KERNAL_SETLFS
        lda # 0                                                 ; No name
        jsr KERNAL_SETNAM
        jsr KERNAL_OPEN
        ldx # DISK_COMMAND_FA
        jsr KERNAL_CHKOUT

        from
            ldy # 0
        loop
            lda [AX],y
            beq _end
            jsr KERNAL_CHROUT
        next
            iny
            bne _loop
        end

        lda # PETSCII_RETURN
        jsr KERNAL_CHROUT
        lda WORK_DEVICE
        jsr PROCESS_DISK_STATUS

        rts
    .endproc

    ;;; summary: Remove (delete, scratch) file
    ;;; changed: A+ X+ Y+ AX+
    .proc CMD_RM
        lda ARGC_LO
        cmp # 2
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
            rts
        else_end

        ; s
        lda # PETSCII_LATIN_LETTER_S
        sta DISK_COMMAND_TEXT + 0
        ; Drive
        clc
        lda WORK_DRIVE
        adc # PETSCII_DIGIT_ZERO
        sta DISK_COMMAND_TEXT + 1
        ; :
        lda # PETSCII_COLON
        sta DISK_COMMAND_TEXT + 2

        from
            lda ARGV_1_LO
            sta AL
            lda ARGV_1_HI
            sta AH
            ldx # 3
            ldy # 0
        loop
            lda [AX],y
            beq _end                                            ; break
            sta DISK_COMMAND_TEXT,x
            iny
            cpy # FILE_NAME_MAX_LENGTH + 1
            if_eq_then
                jsr ERROR_FILE_NAME_TOO_LONG
                rts
            else_end
        next
            inx
            bne _loop                                           ; bra
        end

        lda # PETSCII_RETURN
        sta DISK_COMMAND_TEXT,x
        inx
        txa
        ; A = DISK_COMMAND_TEXT.LENGTH
        ldx # <DISK_COMMAND_TEXT
        ldy # >DISK_COMMAND_TEXT
        jsr KERNAL_SETNAM
        lda # DISK_COMMAND_FA                                   ; DISK_COMMAND_FA = DISK_COMMAND_SA
        tay
        ldx WORK_DEVICE
        jsr KERNAL_SETLFS
        jsr KERNAL_OPEN
        if_cs_then
            jsr ERROR_DEVICE_NOT_PRESENT
            rts
        else_end

        lda WORK_DEVICE
        jsr PROCESS_DISK_STATUS

        rts
    .endproc

    ;;; summary: Move (rename) file
    ;;; changed: A+ X+ Y+ AX+
    .proc CMD_MV
        lda ARGC_LO
        cmp # 3
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
            rts
        else_end

        lda # PETSCII_LATIN_LETTER_R
        sta DISK_COMMAND_TEXT + 0

        clc
        lda WORK_DRIVE
        adc # PETSCII_DIGIT_ZERO
        sta DISK_COMMAND_TEXT + 1
        pha
            lda # PETSCII_COLON
            sta DISK_COMMAND_TEXT + 2

            from
                lda ARGV_2_LO
                sta AL
                lda ARGV_2_HI
                sta AH
                ldx # 3
                ldy # 0
            loop
                lda [AX],y
                beq _end                                        ; break
                sta DISK_COMMAND_TEXT,x
                iny
                cpy # FILE_NAME_MAX_LENGTH + 1
                if_eq_then
                    jsr ERROR_FILE_NAME_TOO_LONG
                    rts
                else_end
            next
                inx
                bne _loop                                       ; bra
            end

            lda # PETSCII_EQUALS_SIGN
            sta DISK_COMMAND_TEXT,x
            inx
        pla
        sta DISK_COMMAND_TEXT,x
        inx
        lda # PETSCII_COLON
        sta DISK_COMMAND_TEXT,x
        inx
        from
            lda ARGV_1_LO
            sta AL
            lda ARGV_1_HI
            sta AH
            ldy # 0
        loop
            lda [AX],y
            beq _end                                            ; break
            sta DISK_COMMAND_TEXT,x
            iny
            cpy # FILE_NAME_MAX_LENGTH + 1
            if_eq_then
                jsr ERROR_FILE_NAME_TOO_LONG
                rts
            else_end
        next
            inx
            bne _loop
        end

        lda # PETSCII_RETURN
        sta DISK_COMMAND_TEXT,x
        inx
        txa
        ldx # <DISK_COMMAND_TEXT
        ldy # >DISK_COMMAND_TEXT
        jsr KERNAL_SETNAM
        lda # DISK_COMMAND_FA                                   ; DISK_COMMAND_FA = DISK_COMMAND_SA
        tay
        ldx WORK_DEVICE
        jsr KERNAL_SETLFS
        jsr KERNAL_OPEN
        if_cs_then
            jsr ERROR_DEVICE_NOT_PRESENT
            rts
        else_end

        lda WORK_DEVICE
        jsr PROCESS_DISK_STATUS

        rts
    .endproc

    ;;; summary: Print (cat) file
    ;;; changed: A+ X+ Y+
    .proc CMD_PR
        lda ARGC_LO
        cmp # 2
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
            rts
        else_end

        ; AX := ARGV[1]
        lda ARGV_1_LO
        sta AL
        lda ARGV_1_HI
        sta AH

        ; Y := ARGV[1].LENGTH
        from
            ldy # 0
        loop
            lda [AX],y
            beq _end                                            ; break
        next
            iny
            bne _loop                                           ; bra
        end

        tya
        ldx AL
        ldy AH
        jsr KERNAL_SETNAM
        lda # FILE_FA                                           ; A = FILE_FA = FILE_SA
        ldx WORK_DEVICE
        tay                                                     ; Y = FILE_SA
        jsr KERNAL_SETLFS
        jsr KERNAL_OPEN
        if_cs_then
            jsr ERROR_DEVICE_NOT_PRESENT
            rts
        else_end

        lda WORK_DEVICE
        jsr PROCESS_DISK_STATUS
        if_cs_then
            rts
        else_end

        jsr BUFFERED_OUT_INIT
        ldx # FILE_FA
        jsr KERNAL_CHKIN

        from_loop
            jsr KERNAL_CHRIN
            tax
            jsr KERNAL_READST
            pha
                txa
                jsr BUFFERED_OUT_BYTE
            pla
        next
            beq _loop
        end

        jsr BUFFERED_OUT_FLUSH

        rts
    .endproc

    ;;;summary: Show or change work disk
    .proc CMD_WORK
        lda ARGC_LO
        cmp # 1
        if_eq_then
            ; Show
            ldx WORK_DEVICE
            ldy WORK_DRIVE
            jsr OUT_DEVICE_DRIVE
            rts
        else_end

        cmp # 3
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
            rts
        else_end

        ; Change
        jsr CHANGE_DEVICE_DRIVE
        if_cc_then
            ; Change went OK
            stx WORK_DEVICE
            sty WORK_DRIVE
        else_end

        rts
    .endproc

    ;;;summary: Show or change system disk
    .proc CMD_SYS
        lda ARGC_LO
        cmp # 1
        if_eq_then
            ; Show
            ldx SYS_DEVICE
            ldy SYS_DRIVE
            jsr OUT_DEVICE_DRIVE
            rts
        else_end

        cmp # 3
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
            rts
        else_end

        ; Change
        jsr CHANGE_DEVICE_DRIVE
        if_cc_then
            ; Change went OK
            stx SYS_DEVICE
            sty SYS_DRIVE
        else_end

        rts
    .endproc

    ;endregion

;
;region Helpers

    ;;; summary: Put string
    ;;; in:
    ;;;   X#Y: Nul-terminated string
    ;;; changed:
    ;;;   A+ X- Y+ AX+
    .proc OUT_STRING
        from
            stx AL
            sty AH
            ldy # 0
        loop
            lda [AX],y
            beq _end                                            ; break
            jsr KERNAL_CHROUT                                   ; A- X- Y- C0
        next
            iny
            bne _loop
        end

        rts
    .endproc

    ;;; summary: Compare nul-terminated strings
    ;;; in:
    ;;;   AX: Left string
    ;;;   BX: Right string
    ;;; out:
    ;;;   Z: Is equal? 0 = no 1=yes
    .proc STRING_COMPARE
        from
            ldy # 0
        loop
            lda [AX],y
            cmp [BX],y
            if_ne_then
                rts
            else_end
        next
            cmp # PETSCII_NUL
            beq _end
            iny
            bne _loop                                               ; bra
        end

        rts
    .endproc

    ;;; summary: Unsigned binary X#Y to decimal (max 9999)
    .proc BINARY_TO_DECIMAL
        stx BINARY_TO_DECIMAL_BINARY_LO
        sty BINARY_TO_DECIMAL_BINARY_HI

        from
            ldx # 3
            lda # PETSCII_SPACE
        loop
            sta BINARY_TO_DECIMAL_DECIMAL,x
        next
            dex
            bpl _loop
        end

        from OUTER
            ldx # 0
            ldy # 3
        loop

            from INNER
                lda # 0
                sta BINARY_TO_DECIMAL_DECIMAL_DIGIT
            loop
                sec
                lda BINARY_TO_DECIMAL_BINARY_LO
                sbc TABLE_BINARY_TO_DECIMAL_LO,y
                sta BINARY_TO_DECIMAL_TMP
                lda BINARY_TO_DECIMAL_BINARY_HI
                sbc TABLE_BINARY_TO_DECIMAL_HI,y
                bcc _end                                        ; break
                sta BINARY_TO_DECIMAL_BINARY_HI
                lda BINARY_TO_DECIMAL_TMP
                sta BINARY_TO_DECIMAL_BINARY_LO
            next
                inc BINARY_TO_DECIMAL_DECIMAL_DIGIT
                bne _loop                                       ; bra
            end

            if
                lda BINARY_TO_DECIMAL_DECIMAL_DIGIT
                bne _then
                cpx # 0
                beq _end
            then
                clc
                adc # PETSCII_DIGIT_ZERO
                sta BINARY_TO_DECIMAL_DECIMAL,x
                inx
            end

        next
            dey
            bpl _loop
        end

        txa
        if_eq_then
            lda # PETSCII_DIGIT_ZERO
            sta BINARY_TO_DECIMAL_DECIMAL
        else_end

        rts
    .endproc

    ;;; summary: Read byte, checking status
    ;;; out:
    ;;;   A: Byte read, if OK
    ;;;   C: 0=OK 1=FAIL
    ;;;   SAVE_KERNAL_READST: Last status
    .proc IN_BYTE
        lda SAVE_KERNAL_READST
        cmp # KERNAL_OK
        if_ne_then
            sec                                                 ; FAIL
            rts
        else_end

        jsr KERNAL_CHRIN
        pha
            jsr KERNAL_READST
            sta SAVE_KERNAL_READST
        pla
        clc                                                     ; OK

        rts
    .endproc

    ;;; summary: Print device number in `X` (could be 8-30, so need 1 or 2 positions) and drive number in `Y' (0 or 1), and reset file I/O.
    ;;; in:
    ;;;   X: Device
    ;;;   Y: Drive
    .proc OUT_DEVICE_DRIVE
        lda # PETSCII_SPACE
        sta STRING_DEVICE_NUMBER_1
        txa
        ldx # 0
        cmp # 10
        if_ge_then
            pha
                lda # PETSCII_DIGIT_ONE
                sta STRING_DEVICE_NUMBER_0
            pla
            sec
            sbc # 10
            inx
        else_end

        clc
        adc # PETSCII_DIGIT_ZERO
        sta STRING_DEVICE_NUMBER_0,x
        clc
        tya
        adc # PETSCII_DIGIT_ZERO
        sta STRING_DRIVE_NUMBER_0
        ldx # <STRING_DEVICE
        ldy # >STRING_DEVICE
        jsr OUT_STRING

        rts
    .endproc

    ;;; summary: Get device and drive number from string at ARGV_1 and ensure device is present.
    ;;; in:
    ;;;   ARGV_1: String
    ;;; out:
    ;;;   X:  Device number: 8,...,19
    ;;;   Y:  Drive number: 0 or 1
    ;;;   C: 0=OK 1=FAIL
    ;;; changed:
    ;;;   A+ X+ Y+ AX BX
    ;;; notes:
    ;;;   We test only if the device is present, not the drive.
    ;;;   This is because it is not possible to test if a drive is present (without a readable disk being present).
    .proc CHANGE_DEVICE_DRIVE
        try
            ; Device number is in ARGV[1]
            lda ARGV_1_LO
            sta AL
            lda ARGV_1_HI
            sta AH
            ldx # 0
            ldy # 0
            lda [AX],y
            cmp # PETSCII_DIGIT_ONE
            if_eq_then
                ; A = "1"
                ldx # 10
                iny
                lda [AX],y
                if_eq_then
                    ; Device "1" is not possible -> error
                    jmp _catch                                  ; throw
                else_end
            else_end

            ; A != "1"
            txa
            clc
            adc [AX],y
            sec
            sbc # PETSCII_DIGIT_ZERO
            ; A: Device number (8,9,10,...,19)
            sta BL

            iny
            lda [AX],y
            if_ne_then
                ; Another character -> error
                jmp _catch                                  ; throw
            else_end

            ; Get drive number from ARGV[1] into STRING_DRIVE_NUMBER_0
            lda ARGV_2_LO
            sta AL
            lda ARGV_2_HI
            sta AH

            ldy # 0
            lda [AX],y
            cmp # PETSCII_DIGIT_ZERO
            if
                bcc _then                                       ; A < "0" -> error
                cmp # PETSCII_DIGIT_TWO
                bcc _end                                       ; A < "2" -> ok
            then
                ; A < "0" || A >= "2"
            else
                jmp _catch
            end

            tax
            iny
            lda [AX],y
            if_ne_then
                ; Another character -> error
                jmp _catch
            else_end

            ; X: drive number as character "0" or "1"
            txa
            sec
            sbc # PETSCII_DIGIT_ZERO
            ; A: drive number
            sta BH

            ; BL: Device number
            ; BH: Drive number
            ; Test if device present by sending Memory Read command
            lda # DISK_COMMAND_FA                           ; DISK_COMMAND_FA = DISK_COMMAND_SA
            ldx BL
            tay
            jsr KERNAL_SETLFS
            ldx # <MR_TEXT
            ldy # >MR_TEXT
            lda # MR_TEXT_LENGTH
            jsr KERNAL_SETNAM
            jsr KERNAL_OPEN
            php
                lda # DISK_COMMAND_FA
                jsr KERNAL_CLOSE
            plp
            bcs _catch                                          ; Device not present -> rethrow

            ; C=0 -> Device is present
            ldx BL
            ldy BH
            ; C=0 OK
            rts
        catch
            jsr ERROR_DRIVE_NOT_PRESENT
            sec                                                 ; FAIL
        finally_end

        rts
    .endproc

    ;;; summary Jump to subroutine indirect
    ;;; in:
    ;;;   DX: Address of souroutine
    .proc JSR_INDIRECT_DX
        jmp [DX]
        rts
    .endproc

    ;endregion

;
;region Errors

    .proc ERROR_COMMAND_NOT_FOUND
        ldx # <RESOURCE_STRING_COMMAND_NOT_FOUND
        ldy # >RESOURCE_STRING_COMMAND_NOT_FOUND
        jsr OUT_STRING

        rts
    .endproc

    .proc ERROR_CANT_OPEN_INPUT_FILE
        ldx # <RESOURCE_STRING_CANT_OPEN_INPUT_FILE
        ldy # >RESOURCE_STRING_CANT_OPEN_INPUT_FILE
        jsr OUT_STRING

        rts
    .endproc

    .proc ERROR_CANT_OPEN_OUTPUT_FILE
        ldx # <RESOURCE_STRING_CANT_OPEN_OUTPUT_FILE
        ldy # >RESOURCE_STRING_CANT_OPEN_OUTPUT_FILE
        jsr OUT_STRING

        rts
    .endproc

    .proc ERROR_PRINTER_NOT_PRESENT
        ldx # <RESOURCE_STRING_PRINTER_NOT_PRESENT
        ldy # >RESOURCE_STRING_PRINTER_NOT_PRESENT
        jsr OUT_STRING

        rts
    .endproc

    ;;; summary: Error: Device not present
    .proc ERROR_DEVICE_NOT_PRESENT
        ldx # <RESOURCE_STRING_DEVICE_NOT_PRESENT
        ldy # >RESOURCE_STRING_DEVICE_NOT_PRESENT
        jsr OUT_STRING

        rts
    .endproc

    ;;; summary: Error: Wrong number of arguments
    .proc ERROR_WRONG_NUMBER_OF_ARGUMENTS
        ldx # <RESOURCE_STRING_WRONG_NUMBER_OF_ARGUMENTS
        ldy # >RESOURCE_STRING_WRONG_NUMBER_OF_ARGUMENTS
        jsr OUT_STRING

        rts
    .endproc

    .proc ERROR_DRIVE_NOT_PRESENT
        ldx # <RESOURCE_STRING_DRIVE_NOT_PRESENT
        ldy # >RESOURCE_STRING_DRIVE_NOT_PRESENT
        jsr OUT_STRING

        rts
    .endproc

    ;;; summary: Error: File name too long
    .proc ERROR_FILE_NAME_TOO_LONG
        ldx # <RESOURCE_STRING_FILE_NAME_TOO_LONG
        ldy # >RESOURCE_STRING_FILE_NAME_TOO_LONG
        jsr OUT_STRING

        rts
    .endproc

    ;endregion

;
;region Buffered output

    ;;; summary: Initialize buffered output
    .proc BUFFERED_OUT_INIT
        lda # 0
        sta BUFFERED_OUT_CURSOR

        rts
    .endproc

    ;;; summary: Send byte in `A` to buffered output, flushing if buffer is full.
    ;;; changed: A+ X+ Y+
    ;;; notes:
    ;;;   Flush on PETSCII_RETURN or buffer full.
    ;;;   Not flushed: A- X- Y-
    ;;;   Flushed: A+ X+ Y+
    .proc BUFFERED_OUT_BYTE
        stx BUFFERED_OUT_SAVE_X
            ldx BUFFERED_OUT_CURSOR
            sta BUFFERED_OUT_BUFFER,x
            inc BUFFERED_OUT_CURSOR
            if
                cmp # PETSCII_RETURN
                beq _then
                cpx # BUFFERED_OUT_BUFFER_SIZE
                bne _end
            then
                jsr BUFFERED_OUT_FLUSH
            else_end
        ldx BUFFERED_OUT_SAVE_X

        rts
    .endproc

    ;;; summary: Flush buffered output
    ;;; changed: A+ X+ Y+
    .proc BUFFERED_OUT_FLUSH
        lda REDIRECT_OUTPUT_ACTIVE
        if_ne_then
            ; Redirect output active
            jsr KERNAL_CLRCHN                                   ; A+ X+
            ldx # REDIRECT_OUTPUT_FA
            jsr KERNAL_CHKOUT                                   ; A+ X+
        else_end

        from
            ldx # 0
        loop
            cpx BUFFERED_OUT_CURSOR
            beq _end                                            ; break
            lda BUFFERED_OUT_BUFFER,x
            jsr KERNAL_CHROUT                                   ; A- X- Y-
        next
            inx
            bne _loop                                           ; bra
        end

        lda REDIRECT_OUTPUT_ACTIVE
        if_ne_then
            ; Redirect output active
            jsr KERNAL_CLRCHN                                   ; A+ X+
            ldx # FILE_FA
            jsr KERNAL_CHKIN                                    ; A+ X+ Y+
        else_end

        jsr BUFFERED_OUT_INIT

        rts
    .endproc

    ;endregion

;
;region NMI handler

    ;;; summary: My NMI handler.
    ;;; notes:
    ;;;   We catch <RUN STOP> + <RESTORE> else we go back to BASIC.
    .proc MY_NMI_HANDLER
        ; check I = 1

        ; Check for and prevent re-entry
        pha
            lda NMI_ENTRY_COUNT
            if_ne_then
                ; Already in an NMI call (not sure how this could happen, maybe on bouncing RESTORE key)
                pla
                rti
            else_end

            ; First entry
            txa
            pha
                tya
                pha
                    ; Disable all CIA-2 interrupts (why?)
                    lda # $7F
                    sta CIA_2_ICR
                    ; Process any pending CIA-2 interrupt.
                    ; NMI occured?
                    ldy CIA_2_ICR
                    if_mi_then
                        ; NMI occured yes
                        jmp KERNAL_NNMI20                       ; Continue at original Kernal NMI handler
                    else_end

                    ; NMI occured no
                    ; RESTORE key was pressed
                    ; STOP key pressed? Z=1 (eq): yes, Z=0 (ne): no
                    jsr KERNAL_STOP
                    if_ne_then
                        ; STOP key was not pressed
                        jmp KERNAL_NNMI20                       ; Continue at original Kernal NMI handler
                    else_end

                    ; STOP key was pressed

                    ; Prevent re-entry
                    inc NMI_ENTRY_COUNT

                    ; Set text screen base to default (in case it got changed).
                    lda # >SCREEN_TEXT_RAM_BASE
                    sta KVAR_HIBASE

                    ; Save and restore colors because called Kernal routine changes them.
                    lda KVAR_COLOR
                    pha
                        lda VIC_EC
                        pha
                            lda VIC_B0C
                            pha
                                jsr KERNAL_IOINIT
                                ; Kernal ioinit:
                                ; Also sets memory configuration to default: BASIC ROM, IO DEVICES, KERNAL ROM, Datasette output off motor off
                                jsr KERNAL_CINT
                                ; Kernal cint:
                                ; Also sets default I/O: output dflto := 3 (screen), input dfltn := 0 (keyboard)
                            pla
                            sta VIC_B0C
                        pla
                        sta VIC_EC
                    pla
                    sta KVAR_COLOR

                    ; Restore stack pointer to where it was on NMI.
                    ldx SAVE_S
                    txs

                    ; Enable interrupts so we can do file I/O.
                    cli

                    jsr RESET_FILE_IO

                    dec NMI_ENTRY_COUNT                         ; Allow entry
                    jmp RUN                                     ; Resume
    .endproc

    ;endregion

;
;region Maps

    ;;; summary: Map command name to number
    ;;; in:
    ;;;   BX: Candidate: nul-terminated string
    ;;; out:
    ;;;   X: Command number, if Z=1
    ;;;   Z: 1 = found , 0 = not found
    .proc MAP_COMMAND_NAME_TO_COMMAND_NUMBER
        from
            ldx # TABLE_COMMAND_NAME_SIZE - 1
        loop
            lda TABLE_COMMAND_NAME_LO, x
            sta AL
            lda TABLE_COMMAND_NAME_HI, x
            sta AH
            jsr STRING_COMPARE                                  ; A+ X- Y+
            beq _end                                            ; Z=1 -> equal -> break
        next
            dex
            bpl _loop
            ; N=1 Z=0 -> Exhausted
        end

        rts
    .endproc

    ;endregion

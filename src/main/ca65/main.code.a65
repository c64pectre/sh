;    sh: Shell for Commodore 64.
;    Copyright (C) 2026  C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/exehdr/ create an issue

DEFAULT_DEVICE = 8
DEFAULT_DRIVE = 0

DISK_COMMAND_FA = 15
DISK_COMMAND_SA = 15

REDIRECT_INPUT_FA = 1
REDIRECT_INPUT_SA = 2

REDIRECT_OUTPUT_FA = 2
REDIRECT_OUTPUT_FILE_SA = 3
REDIRECT_OUTPUT_PRINTER_DA = 4
REDIRECT_OUTPUT_PRINTER_SA = 7

FILE_FA = 4
FILE_SA = 4

FILE_NAME_TEXT_COLON_OFFSET_NAME = 2

COMMAND_NAME_SIZE = 5

ARGC_MAX = 10

ARGV_SIZE = ARGC_MAX

PROGRAM_ENTRYPOINT = $1800                                  ; Entry point of loaded program

RM_TEXT_OFFSET_NAME = 3

KERNAL_NNMI20 := $FE72                                      ; Kernal nnmi20 continuation of NMI handing.

; ARGC: Argument count
.export ARGC                        := KERNAL_TBUFFR        ; $033C
.export ARGC_LO                     := ARGC                 ; $033C
.export ARGC_HI                     := ARGC + 1             ; $033D

; PARGV: Pointer to argv: argument value array: array of pointer to string
.export PARGV                       := KERNAL_TBUFFR + 2    ; $033E
.export PARGV_LO                    := PARGV                ; $033E
.export PARGV_HI                    := PARGV + 1            ; $033F

.export NEW_SYS_DEVICE              := $17FA                ; $0340    
.export NEW_SYS_DRIVE               := $17FB                ; $0341
.export NEW_WORK_DEVICE             := $17FC                ; $0342
.export NEW_WORK_DRIVE              := $17FD                ; $0343
.export NEW_REDIRECT_INPUT_ACTIVE   := $17FE                ; $0344 0=no , 1=yes
.export NEW_REDIRECT_OUTPUT_ACTIVE  := $17FF                ; $0345 0=no , 1=yes

ARGV                        := $0346
ARGV_0                      := ARGV + 0             ; $0346
ARGV_0_LO                   := ARGV_0               ; $0346
ARGV_0_HI                   := ARGV_0 + 1           ; $0347
ARGV_1                      := ARGV + 2             ; $0348
ARGV_1_LO                   := ARGV_1               ; $0348
ARGV_1_HI                   := ARGV_1 + 1           ; $0349
ARGV_2                      := ARGV + 4             ; $034A
ARGV_2_LO                   := ARGV_2               ; $034A
ARGV_2_HI                   := ARGV_2 + 1           ; $034B
ARGV_3                      := ARGV + 6             ; $034C
ARGV_3_LO                   := ARGV_3               ; $034C
ARGV_3_HI                   := ARGV_3 + 1           ; $034D
ARGV_4                      := ARGV + 8             ; $034E
ARGV_4_LO                   := ARGV_4               ; $034E
ARGV_4_HI                   := ARGV_4 + 1           ; $034F
ARGV_5                      := ARGV + 10            ; $0350
ARGV_5_LO                   := ARGV_5               ; $0350
ARGV_5_HI                   := ARGV_5 + 1           ; $0351
ARGV_6                      := ARGV + 12            ; $0352
ARGV_6_LO                   := ARGV_6               ; $0352
ARGV_6_HI                   := ARGV_6 + 1           ; $0353
ARGV_7                      := ARGV + 14            ; $0354
ARGV_7_LO                   := ARGV_7               ; $0354
ARGV_7_HI                   := ARGV_7 + 1           ; $0355
ARGV_8                      := ARGV + 16            ; $0356
ARGV_8_LO                   := ARGV_8               ; $0356
ARGV_8_HI                   := ARGV_8 + 1           ; $0357
ARGV_9                      := ARGV + 18            ; $0358
ARGV_9_LO                   := ARGV_9               ; $0358
ARGV_9_HI                   := ARGV_9 + 1           ; $0359

;;; summary: Input text $035A-03AB (82 bytes)
INPUT_TEXT                  := $035A
INPUT_TEXT_LAST             := $03AB

;;; summary: Name of loaded program, if any (then LOADED_PROGRAM_NAME[0] == 0) (20 bytes)
LOADED_PROGRAM_NAME         := $03AC
LOADED_PROGRAM_NAME_LAST    := $03BF

SAVE_KVAR_COLOR             := $03C0
SAVE_VIC_EC                 := $03C1
SAVE_VIC_B0C                := $03C2

SAVE_KERNAL_NMINV_LO        := $03C3
SAVE_KERNAL_NMINV_HI        := $03C4
SAVE_S                      := $03C5
NMI_ENTRY_COUNT             := $03C6

LOAD_PROGRAM_SAVE_X_DEVICE  := $03C7

BUFFER_FIRST                := $03C8
BUFFER_LAST                 := $03FF

; Memory area 2 $02A7-$02FF (89 bytes)
AREA_2 := $02A7
AREA_2_FIRST := AREA_2
AREA_2_LAST := $02FF
AREA_2_SIZE = AREA_2_LAST + 1 - AREA_2


FILE_NAME_TEXT := AREA_2
FILE_NAME_TEXT_DRIVE := AREA_2
FILE_NAME_TEXT_COLON := AREA_2 + 1

DISK_STATUS_TEXT := AREA_2
DISK_STATUS_TEXT_CODE_0 := AREA_2
DISK_STATUS_TEXT_CODE_1 := AREA_2 + 1

.export SYS_DEVICE              := $17FA                    
.export SYS_DRIVE               := $17FB
.export WORK_DEVICE             := $17FC
.export WORK_DRIVE              := $17FD
.export REDIRECT_INPUT_ACTIVE   := $17FE                    ; 0 = no , 1 = yes
.export REDIRECT_OUTPUT_ACTIVE  := $17FF                    ; 0 = no , 1 = yes

.exportzp ZP_23 := $23  ; Was ZP_2A
.exportzp ZP_24 := $24  ; Was ZP_2B

.exportzp ZP_25 := $25  ; Was ZP_57
.exportzp ZP_26 := $26  ; Was ZP_58

.exportzp ZP_27 := $27  ; Was ZP_59

.proc main
    jsr INITIALIZE
    jsr RUN
    rts
.endproc

.proc INITIALIZE
    ; Save NMI handler
    lda KERNAL_NMINV_LO
    sta SAVE_KERNAL_NMINV_LO
    lda KERNAL_NMINV_HI
    sta SAVE_KERNAL_NMINV_HI

    ; Save stack pointer
    tsx
    stx SAVE_S

    ; Set border color (TODO Make configurable)
    lda CONFIG_BORDER_COLOR
    sta VIC_EC

    ; Set background color (TODO Make configurable)
    lda CONFIG_BACKGROUND_COLOR
    sta VIC_B0C

    ; Set foreground color (TODO Make configurable)
    lda CONFIG_FOREGROUND_COLOR_CHAR
    jsr KERNAL_CHROUT

    ; Clear screen
    lda # PETSCII_CLR
    jsr KERNAL_CHROUT

    ; Set system and work device to default device (8)
    lda # DEFAULT_DEVICE
    sta SYS_DEVICE
    sta WORK_DEVICE

    ; Set to device number of current file, if any
    lda ZPKERNAL_FA
    if_ne_then
        sta SYS_DEVICE
        sta WORK_DEVICE
    else_end
    ;
    ; Set system and work drive to 0, i.e. single side, or upper side of double sided drive.
    lda # DEFAULT_DRIVE
    sta SYS_DRIVE
    sta WORK_DRIVE

    lda # 0
    ; Reset NMI entry count
    sta NMI_ENTRY_COUNT                                     ; NMI_ENTRY_COUNT = 0

    ; Set no program loaded
    sta LOADED_PROGRAM_NAME

    ; ARGC = 0. Note: ARGC_HI is always 0 because ARGC_MAX = 10
    sta ARGC_LO
    sta ARGC_HI

    ; PARGV = &ARGV
    lda     # <ARGV
    sta     PARGV_LO
    lda     # >ARGV
    sta     PARGV_HI

    rts
.endproc

.proc RUN
    ; Set our NMI handler (set here because RUN-STOP RESTORE resets to default handler)
    lda # <MY_NMI_HANDLER
    sta KERNAL_NMINV_LO
    lda # >MY_NMI_HANDLER
    sta KERNAL_NMINV_HI

    lda # PETSCII_SHIFTED_MODE
    jsr KERNAL_CHROUT

    from_loop
        jsr SHOW_PROMPT
        jsr KEYBOARD_READ_LINE_TO_INPUT_TEXT
        jsr PROCESS_INPUT_TEXT
    next
        jmp _loop
    end

    ; Does not come here
.endproc

.proc SHOW_PROMPT
    lda # PETSCII_DOLLAR
    jsr KERNAL_CHROUT
    lda # PETSCII_SPACE
    jmp KERNAL_CHROUT
.endproc

.proc KEYBOARD_READ_LINE_TO_INPUT_TEXT
    from
        ldy # 0
    loop
        jsr KERNAL_CHRIN                                    ; A+ X+ Y-
        cmp # PETSCII_RETURN
        beq _end                                            ; break
        sta INPUT_TEXT,y
    next
        iny
        bne _loop
    end
    
    jsr KERNAL_CHROUT
    lda # PETSCII_NUL
    sta INPUT_TEXT,y

    rts
.endproc

;;; summary: Put string
;;; in:
;;;   X#Y: Nul-terminated string
;;; changed:
;;;   AX
.proc OUT_STRING
    from
        stx AL
        sty AH
        ldy # 0
    loop
        lda [AX],y
        beq _end                                            ; break
        jsr KERNAL_CHROUT                                   ; A- X- Y- C0
    next
        iny
        bne _loop
    end

    rts
.endproc

;;; summary: My NMI handler.
;;; notes:
;;;   We need to catch <RUN STOP> + <RESTORE> else we go back to BASIC
;;;   Bug: Pressing <RUN STOP> + <RESTORE> during load is handled incorrectly.
.proc MY_NMI_HANDLER
    ; check I = 1

    ; Check for and prevent re-entry
    pha
    lda NMI_ENTRY_COUNT
    if_ne_then
        ; Already in an NMI call (not sure how this could happen, maybe on bouncing RESTORE key)
        pla
        rti
    else_end

    ; First entry
    txa
    pha
        tya
        pha
            ; Disable all CIA-2 interrupts (why?)
            lda # $7F
            sta CIA_2_ICR
            ; Process any pending CIA-2 interrupt.
            ; NMI occured?
            ldy CIA_2_ICR
            if_mi_then
                ; NMI occured yes
                jmp KERNAL_NNMI20                               ; Continue at original Kernal NMI handler
            else_end

            ; NMI occured no
            ; RESTORE key was pressed
            ; STOP key pressed? Z=1 (eq): yes, Z=0 (ne): no
            jsr KERNAL_STOP
            if_ne_then
                ; STOP key was not pressed
                jmp KERNAL_NNMI20                               ; Continue at original Kernal NMI handler
            else_end

            ; STOP key was pressed
            inc NMI_ENTRY_COUNT                          ; Prevent re-entry

            ; Set memory configuration to default: BASIC ROM, IO DEVICES, KERNAL ROM, Datasette output off motor off (in case they got changed).
            lda # CPU_PORT_DATA_DEFAULT
            sta CPU_PORT_DATA

            ; Set text screen base to default (in case it got changed).
            lda # >SCREEN_TEXT_RAM_BASE
            sta KVAR_HIBASE

            ; Save and restore colors because called Kernal routine changes them.
            lda KVAR_COLOR
            pha
                lda VIC_EC
                pha
                    lda VIC_B0C
                    pha
                        jsr KERNAL_IOINIT
                        jsr KERNAL_CINT
                    pla
                    sta VIC_B0C
                pla
                sta VIC_EC
            pla
            sta KVAR_COLOR

            ; Restore stack pointer (stack might have been messed up).
            ldx SAVE_S
            txs

            ; Enable interrupts so we can do file I/O.
            cli

            ; Close all files 14..1. Why not call KERNAL_CLALL?
            from
                ldx # 15
            loop
                txa
                pha
                    jsr KERNAL_CLOSE                        ; A+ X+ Y+ C+ N+ V? Z+
                pla
                tax
            next
                dex
                bne _loop
            end

            lda     # PETSCII_RETURN
            jsr     KERNAL_CHROUT

            dec     NMI_ENTRY_COUNT                          ; Allow entry

            jmp     RUN                                     ; Resume
.endproc

;;; summary: Process input text
;;; in:
;;;   INPUT_TEXT: Input text, nul terminated
.proc PROCESS_INPUT_TEXT
    ldy # 0
    sty ARGC_LO
    sty REDIRECT_INPUT_ACTIVE                               ; Redirect input inactive
    sty REDIRECT_OUTPUT_ACTIVE                              ; Redirect output inactive

    from OUTER
        ldx # $FF                                           ; -1
    loop
        ; Skip any SPACE and NO_BREAK_SPACE
        inx
        lda INPUT_TEXT,x
        if_eq_then
            jmp OUTER::_end                                ; break
        else_end

        ; Skip any space or no-break space    
        cmp # PETSCII_SPACE
        beq OUTER::_loop
        cmp # PETSCII_NO_BREAK_SPACE
        beq OUTER::_loop
            
        ; Redirect input from file?
        cmp # PETSCII_LESS_THAN_SIGN
        if_eq_then
            ; Yes
            jsr REDIRECT_INPUT_FROM_FILE
            bcc OUTER::_loop                                ; OK -> continue

            ; Error redirecting input from file
            ldx # <RESOURCE_STRING_CANT_OPEN_INPUT_FILE
            ldy # >RESOURCE_STRING_CANT_OPEN_INPUT_FILE
            jsr OUT_STRING
            jsr RESET_FILE_IO
            rts
        else_end

        ; Redirect output to file or printer?
        cmp # PETSCII_GREATER_THAN_SIGN
        if_eq_then
            inx
            lda INPUT_TEXT,x
            cmp # PETSCII_GREATER_THAN_SIGN
            if_eq_then
                ; Redirect output to printer
                jsr REDIRECT_OUTPUT_TO_PRINTER
                bcc OUTER::_loop                            ; OK -> continue

                ; Error redirecting output to prinyer
                ldx # <RESOURCE_STRING_PRINTER_NOT_PRESENT
                ldy # >RESOURCE_STRING_PRINTER_NOT_PRESENT
                jsr OUT_STRING
                jsr RESET_FILE_IO
                rts
            else_end

            ; Redirect output to file
            dex
            jsr REDIRECT_OUTPUT_TO_FILE
            bcc OUTER::_loop                                ; OK -> continue

            ; Error redirecting output to file
            ldx # <RESOURCE_STRING_CANT_OPEN_OUTPUT_FILE
            ldy # >RESOURCE_STRING_CANT_OPEN_OUTPUT_FILE
            jsr OUT_STRING
            jsr RESET_FILE_IO
            rts
        else_end

        ; We have the start of an argument.
        inc ARGC_LO
        ; Quoted argument?
        cmp # PETSCII_QUOTATION_MARK
        if_eq_then
            ; Yes
            inx
            jsr SET_NEXT_ARGV
            dex

            from_loop
                inx
                lda INPUT_TEXT,x
                beq OUTER::_end                             ; EOI -> break
            next
                ; Closing quotation mark?
                cmp # PETSCII_QUOTATION_MARK
                bne _loop
            end

            ; Found closing quotation mark
            lda # PETSCII_NUL
            sta INPUT_TEXT,x
            jmp OUTER::_loop                                ; continue
        else_end

        jsr SET_NEXT_ARGV

        from_loop INNER
            inx
            lda INPUT_TEXT,x
            beq OUTER::_end                                 ; EOI -> break
            cmp # PETSCII_SPACE
            beq INNER::_END                                 ; break
        next
            cmp # PETSCII_NO_BREAK_SPACE
            bne INNER::_loop
        end

        lda # PETSCII_NUL
        sta INPUT_TEXT,x
    next
        jmp _loop
    end

    ; Finished parsing input text
    ; Have we got any arguments?
    lda ARGC_LO
    if_ne_then
        ; We have got arguments
        lda ARGV_0_LO
        sta ZP_23
        lda ARGV_0_HI
        sta ZP_24
        ldy # 0
        lda [ZP_23],y
        if_ne_then
            ; ARGV[0][0] != PETSCII_NUL
            jsr TRY_BUILT_IN_COMMAND
            ; If built-in, returns by pulling return address.
            jsr LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
            if_cc_then
                jsr EXECUTE_PROGRAM
            else_end
        else_end
    else_end

    jsr RESET_FILE_IO
    rts
.endproc

;;; summary: Load program with name from `LOADED_PROGRAM_NAME`, if not already done so.
;;; in:
;;;   ZP_23#ZP_24: Name of program to load.
;;; out:
;;;   C: 0=OK 1=FAIL
.proc LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
    lda # <LOADED_PROGRAM_NAME
    sta ZP_25
    lda # >LOADED_PROGRAM_NAME
    sta ZP_26
    jsr STRING_COMPARE_23_25
    bne LOAD_PROGRAM_FROM_WORK_OR_SYS_DISK
    clc                                                     ; OK
    rts
.endproc

;;; summary: load program from work disk or else from system disk
.proc LOAD_PROGRAM_FROM_WORK_OR_SYS_DISK
            ; Try work disk
            ldx     WORK_DEVICE
            ldy     WORK_DRIVE
            jsr     LOAD_PROGRAM
            bcc     L0E2F                                   ; Load succeeded
            ; Load from work disk failed; try system disk
            ldx     SYS_DEVICE
            ldy     SYS_DRIVE
            jsr     LOAD_PROGRAM
            bcc     L0E2F                                   ; Load succeeded
            ; Load failed
            ldx     # <RESOURCE_STRING_COMMAND_NOT_FOUND
            ldy     # >RESOURCE_STRING_COMMAND_NOT_FOUND
            jsr     OUT_STRING
            sec                                             ; FAIL
            rts
    L0E2F:
            ldy     # 19
    L0E31:
            lda     [ZP_23],y
            sta     LOADED_PROGRAM_NAME,y
            dey
            bpl     L0E31
            clc                                             ; OK
            rts
.endproc

;;; summary: Execute loaded program
;;; notes:
;;;   Entry point is at $1800
;;; changed: A+ X+ Y+ ZP_23#ZP_24
.proc EXECUTE_PROGRAM
    ; Save colors
    lda KVAR_COLOR
    sta SAVE_KVAR_COLOR
    lda VIC_EC
    sta SAVE_VIC_EC
    lda VIC_B0C
    sta SAVE_VIC_B0C

    ; Call program's entrypoint
    jsr PROGRAM_ENTRYPOINT

    ; Restore colors
    lda SAVE_VIC_EC
    sta VIC_EC
    lda SAVE_VIC_B0C
    sta VIC_B0C
    lda SAVE_KVAR_COLOR
    sta KVAR_COLOR
    ; Set all character color
    from OUTER
        ldx # >SCREEN_COLOR_RAM_BASE
        ldy # <SCREEN_COLOR_RAM_BASE
        sty ZP_23
    loop
        from INNER
            stx ZP_24
        loop
            sta [ZP_23],y
        next
            iny
            bne _loop
        end
    next
        inx
        cpx # SCREEN_COLOR_RAM_PAGE_LAST + 1
        bne OUTER::_loop
    end

    rts
.endproc

;;; summary: Back to default file I/O
.proc RESET_FILE_IO

    lda # REDIRECT_INPUT_FA
    jsr KERNAL_CLOSE

    lda # REDIRECT_OUTPUT_FA
    jsr KERNAL_CLOSE

    lda # DISK_COMMAND_FA
    jsr KERNAL_CLOSE

    jsr KERNAL_CLRCHN

    lda # 0
    sta REDIRECT_INPUT_ACTIVE                               ; Redirect input inactive
    sta REDIRECT_OUTPUT_ACTIVE                              ; Redirect output inactive

    rts
.endproc

;;; summary: Load program
;;; in:
;;;   X: Device
;;;   Y: Drive
;;;   ZP_23#ZP_24   File name
.proc LOAD_PROGRAM
    stx LOAD_PROGRAM_SAVE_X_DEVICE
    tya
    clc
    adc # PETSCII_DIGIT_ZERO
    sta FILE_NAME_TEXT_DRIVE
    lda # PETSCII_COLON
    sta FILE_NAME_TEXT_COLON
    from
        ldy # 0
        ldx # FILE_NAME_TEXT_COLON_OFFSET_NAME              ; 2
    loop
        lda [ZP_23],y
        beq _end                                            ; NUL -> break
        sta     FILE_NAME_TEXT,x
    next
        iny
        inx
        bne _loop
    end
    
    ; Add ".sh"
    lda # PETSCII_FULL_STOP
    sta FILE_NAME_TEXT,x
    inx
    lda # PETSCII_LATIN_LETTER_S
    sta FILE_NAME_TEXT,x
    inx
    lda # PETSCII_LATIN_LETTER_H
    sta FILE_NAME_TEXT,x
    inx                                                     ; X = FILE_NAME_TEXT.LENGTH
    txa                                                     ; A = X = FILE_NAME_TEXT.LENGTH
    ldx # <FILE_NAME_TEXT
    ldy # >FILE_NAME_TEXT
    jsr KERNAL_SETNAM
    ldx LOAD_PROGRAM_SAVE_X_DEVICE
    lda # FILE_FA                                           ; A = FILE_FA = FILE_SA
    tay                                                     ; Y = FILE_SA
    jsr KERNAL_SETLFS
    lda # KERNAL_LOAD_LOAD
    jsr KERNAL_LOAD
    if_cs_then
        ; Load error
        cmp # KERNAL_ERROR_DEVICE_NOT_PRESENT
        if_eq_then
            ; Device not present
            rts
        else_end

        ; Device present. (Attempt to) read (but not show) disk status.
        lda # DISK_COMMAND_FA                       ; DISK_COMMAND_FA = DISK_COMMAND_SA
        ldx LOAD_PROGRAM_SAVE_X_DEVICE
        tay
        jsr KERNAL_SETLFS
        lda # 0                                     ; No name
        jsr KERNAL_SETNAM
        jsr KERNAL_OPEN
        if_cc_then
            ldx # DISK_COMMAND_FA
            jsr KERNAL_CHKIN
            if_cc_then
                from_loop
                    jsr KERNAL_CHRIN
                next
                    cmp # PETSCII_RETURN
                    bne _loop
                end
            else_end
        else_end

        lda  # DISK_COMMAND_FA
        jsr KERNAL_CLOSE
        jsr KERNAL_CLRCHN
        sec                                                 ; FAIL
    else_end

    rts
.endproc

;;; summary: Set next argv from input text `INPUT_TEXT` at position `X`.
;;; in:
;;;   X: Position in INPUT_TEXT
;;; changed:
;;;   ARGV[]
;;;   A+ X- Y+
.proc SET_NEXT_ARGV
    clc
    txa
    adc # <INPUT_TEXT
    sta ARGV,y
    iny
    lda # 0
    adc # >INPUT_TEXT
    sta ARGV,y
    iny

    rts
.endproc

;;; summary: redirect input from file named `FILE_NAME_TEXT` extracted from `INPUT_TEXT` on work disk
;;; in:
;;;   INPUT_TEXT: Input text
;;;   Y:
;;; out:
;;;   REDIRECT_INPUT_ACTIVE: Set to 1: redirect input active
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+
.proc REDIRECT_INPUT_FROM_FILE
    lda # 1
    sta REDIRECT_INPUT_ACTIVE
    sty ZP_24
    jsr GET_FILE_NAME_FROM_INPUT_TEXT_FOR_WORK_DRIVE
    if_cs_then
        rts
    else_end

    tya
    ldx # <FILE_NAME_TEXT
    ldy # >FILE_NAME_TEXT
    jsr KERNAL_SETNAM
    lda # REDIRECT_INPUT_FA
    ldx WORK_DEVICE
    ldy # REDIRECT_INPUT_SA
    jsr KERNAL_SETLFS
    jsr KERNAL_OPEN
    if_cs_then
        rts
    else_end

    lda WORK_DEVICE
    jsr PROCESS_DISK_STATUS

    rts
.endproc

;;; summary: Redirect output to file named `FILE_NAME_TEXT` extracted from `INPUT_TEXT` on work disk
.proc REDIRECT_OUTPUT_TO_FILE
    lda # 1
    sta REDIRECT_OUTPUT_ACTIVE
    sty ZP_24
    jsr GET_FILE_NAME_FROM_INPUT_TEXT_FOR_WORK_DRIVE
    if_cs_then
        ; FAIL
        rts
    else_end

    dey
    dey
    lda FILE_NAME_TEXT,y
    iny
    iny
    cmp # PETSCII_COMMA
    if_ne_then
        lda # PETSCII_COMMA
        sta FILE_NAME_TEXT,y
        iny
        lda # PETSCII_LATIN_LETTER_S
        sta FILE_NAME_TEXT,y
        iny
    else_end

    lda # PETSCII_COMMA
    sta FILE_NAME_TEXT,y
    iny
    lda # PETSCII_LATIN_LETTER_W
    sta FILE_NAME_TEXT,y
    iny
    tya
    ldx # <FILE_NAME_TEXT
    ldy # >FILE_NAME_TEXT
    jsr KERNAL_SETNAM                                       ; A=NAME.LENGTH X=<NAME Y=>NAME
    lda # REDIRECT_OUTPUT_FA
    ldx WORK_DEVICE
    ldy # REDIRECT_OUTPUT_FILE_SA
    jsr KERNAL_SETLFS                                       ; A=FA X=DA Y=SA
    jsr KERNAL_OPEN
    if_cs_then
        ; FAIL
        rts
    else_end

    lda WORK_DEVICE
    jsr PROCESS_DISK_STATUS

    rts
.endproc

;;; summary: Read disk status of device `A` into `DISK_STATUS_TEXT`, printing if not equal to "00"
;;; in:
;;;   A: Device Address (DA)
;;; out:
;;;   DISK_STATUS_TEXT: Disk status that has been read
;;;   C: 0=OK 1=FAIL
;;;   X: = ZP_23
;;;   Y: = ZP_24
.proc PROCESS_DISK_STATUS
    pha
        lda # 0
        jsr KERNAL_SETNAM                                   ; No name
    pla
    tax                                                     ; X = A' = DA
    lda # DISK_COMMAND_FA                                   ; A = DISK_COMMAND_FA = DISK_COMMAND_SA
    tay                                                     ; Y = DISK_COMMAND_SA
    jsr KERNAL_SETLFS                                       ; A=FA X=DA Y=SA
    jsr KERNAL_OPEN
    ldx # DISK_COMMAND_FA
    jsr KERNAL_CHKIN
    from
        ldy # 0
    loop
        jsr KERNAL_CHRIN
        sta DISK_STATUS_TEXT,y
        iny
    next
        cmp # PETSCII_RETURN
        bne _loop
    end

    jsr KERNAL_CLRCHN

    if
        lda DISK_STATUS_TEXT_CODE_0
        cmp # PETSCII_DIGIT_ZERO
        bne _then
        lda DISK_STATUS_TEXT_CODE_1
        cmp # PETSCII_DIGIT_ZERO
        beq _else
    then
        ; ! (DISK_STATUS_TEXT_CODE_0 = "0" & DISK_STATUS_TEXT_CODE_1 = "0")
        ; Error
        jsr OUT_DISK_STATUS_TEXT
        sec
        bcs _end                                            ; bra
    else
        ; OK
        clc
    end

    ldx ZP_23
    ldy ZP_24

    rts
.endproc

;;; summary: Print disk status text to output (presumably screen)
.proc OUT_DISK_STATUS_TEXT
    from
        ldy # 0
    loop
        lda DISK_STATUS_TEXT,y
        cmp # PETSCII_RETURN
        beq _end                                            ; break
        jsr KERNAL_CHROUT
    next
        iny
        bne _loop                                           ; bra
    L103E:
    end

    ; Print the  RETURN too    
    jsr KERNAL_CHROUT

    rts
.endproc

;;; summary: Get (extract) file name from `INPUT_TEXT` from position `X`, prefixed with work drive and colon.
;;; in:
;;;   INPUT_TEXT: Input text
;;;   X: Starting position
;;; out:
;;;   FILE_NAME_TEXT: Extracted file name
;;;   X: Last position in `INPUT_TEXT` of extracted file name
;;;   ZP_23: Same as `X`
;;;   C: 0=OK 1=FAIL
;;; notes:
;;;   TODO Quoted file name is not possible
.proc GET_FILE_NAME_FROM_INPUT_TEXT_FOR_WORK_DRIVE
    clc
    lda WORK_DRIVE
    adc # PETSCII_DIGIT_ZERO
    sta FILE_NAME_TEXT_DRIVE
    lda # PETSCII_COLON
    sta FILE_NAME_TEXT_COLON

    ; Skip any space and no break space
    from_loop
        inx
        lda INPUT_TEXT,x
        if_eq_then
            ; No file name
            sec                                             ; FAIL
            rts
        else_end

    next
        cmp # PETSCII_SPACE
        beq _loop                                           ; continue
        cmp # PETSCII_NO_BREAK_SPACE
        beq _loop
    end

    from
        ldy # 2
    loop
        lda INPUT_TEXT,x
        beq _end                                            ; break
        cmp # PETSCII_SPACE
        beq _end                                            ; break
        cmp # PETSCII_NO_BREAK_SPACE
        beq _end
        sta FILE_NAME_TEXT,y
    next
        iny
        inx
        bne _loop                                           ; bra
    end

    dex
    stx ZP_23
    clc                                                     ; OK

    rts
.endproc

;;; summary: Redirect output to printer (device 4)
;;; out:
;;;   C: 0=OK 1=FAIL
.proc REDIRECT_OUTPUT_TO_PRINTER
    stx ZP_23
    sty ZP_24

    lda # 1
    sta REDIRECT_OUTPUT_ACTIVE

    lda # REDIRECT_OUTPUT_FA
    ldx # REDIRECT_OUTPUT_PRINTER_DA
    ldy # REDIRECT_OUTPUT_PRINTER_SA
    jsr KERNAL_SETLFS
    lda # 0                                                 ; No name
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    if_cc_then
        ldx # REDIRECT_OUTPUT_FA
        jsr KERNAL_CHKOUT
    else_end

    php
        jsr KERNAL_CLRCHN
    plp

    ldx ZP_23
    ldy ZP_24

    rts
.endproc

; Used in PROC_B, PROC_C, PROC_D
L10AB:  .byte   0

.proc PROC_C
    stx BINARY_TO_DECIMAL_TMP
    ldx L10AB
    sta KERNAL_TBUFFR,x
    inc L10AB
    cmp # PETSCII_RETURN
    beq PROC_D
    ldx BINARY_TO_DECIMAL_TMP
    rts
.endproc

.proc PROC_D
    lda REDIRECT_OUTPUT_ACTIVE
    if_ne_then
        ; Redirect output active
        jsr KERNAL_CLRCHN
        ldx # REDIRECT_OUTPUT_FA
        jsr KERNAL_CHKOUT
    else_end

    from
        ldx # 0
    loop
        cpx L10AB
        beq _end                                            ; break
        lda KERNAL_TBUFFR,x
        jsr KERNAL_CHROUT
    next
        inx
        bne _loop                                           ; bra
    end

    lda REDIRECT_OUTPUT_ACTIVE
    if_ne_then
        ; Redirect output active
        jsr KERNAL_CLRCHN
        ldx # FILE_FA
        jsr KERNAL_CHKIN
    else_end

    ldx BINARY_TO_DECIMAL_TMP
    jsr PROC_B
    rts
.endproc

.proc PROC_B
    lda # 0
    sta L10AB
    rts
.endproc

.proc TRY_BUILT_IN_COMMAND
    from
        lda # <COMMAND_NAME_TABLE
        sta ZP_25
        lda # >COMMAND_NAME_TABLE
        sta ZP_26
        lda # 0
        sta ZP_27
    loop
        ldy # 0
        lda [ZP_25],y
        if_eq_then
            rts
        else_end

        jsr STRING_COMPARE_23_25
        beq _end                                            ; break
    next
        clc
        lda ZP_25
        adc # COMMAND_NAME_SIZE
        sta ZP_25
        if_cs_then
            inc ZP_26
        else_end

        inc ZP_27
        bne _loop                                           ; bra
    end

    ; Take out return address so we return from PROCESS_INPUT_TEXT (yuk!)
    pla
    pla

    ldx ZP_27
    if_eq_then
        ; Bye
        jsr RESET_FILE_IO
        lda SAVE_KERNAL_NMINV_LO
        sta KERNAL_NMINV_LO
        lda SAVE_KERNAL_NMINV_HI
        sta KERNAL_NMINV_HI
        ldx SAVE_S
        txs
        rts
    else_end

    dex
    if_eq_then
        ; Load
        lda ARGC_LO
        cmp # 2
        if_ne_then
            jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
            rts
        else_end

        lda ARGV_1_LO
        sta ZP_23
        lda ARGV_1_HI
        sta ZP_24
        jsr LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
        jsr RESET_FILE_IO
        rts
    else_end

    dex
    if_eq_then
        ; ls
        ldx SYS_DEVICE
        ldy SYS_DRIVE
        jsr CMD_DIR
        rts
    else_end

    dex
    if_eq_then
        ; l
        ldx WORK_DEVICE
        ldy WORK_DRIVE
        jsr CMD_DIR
        rts
    else_end

    dex
    if_eq_then
        ; rm
        jsr CMD_RM
        rts
    else_end

    dex
    if_eq_then
        ; mv
        jsr CMD_MV
        rts
    else_end

    dex
    if_eq_then
        ; pr
        jsr CMD_PR
        rts
    else_end

    dex
    if_eq_then
        ; disk
        jsr CMD_DISK
        rts
    else_end
    
    dex
    if_eq_then
        ; work
        jsr CMD_WORK
        rts
    else_end
    
    dex
    if_eq_then
        ; sys
        jsr CMD_SYS
        rts
    else_end

    jsr STRING_COMPARE_23_25                                ; Why?

    rts
    
.endproc

;;; summary: Compare non-empty (!) nul-terminated strings `ZP_23` and `ZP_25`
;;; in:
;;;   ZP_23: Left string
;;;   ZP_25: Right string
;;; out:
;;;   Z: Is equal? 0 = no 1=yes
.proc STRING_COMPARE_23_25
    from
        ldy # 0
    loop
        lda [ZP_23],y
        cmp [ZP_25],y
        if_ne_then
            rts
        else_end
    next
        iny
        cmp # PETSCII_NUL
        bne _loop
    end

    rts
.endproc

;;; summary: Command: directory listing of work or system disk
;;; in:
;;;   X: Device address (8-31) DA
;;;   Y: Drive number (0-1) DN
.proc CMD_DIR
    txa                                                     ; A = DA
    pha                                                     ; STACK = [DA]...
        tya
        clc
        adc # PETSCII_DIGIT_ZERO
        sta DIR_NAME_DRIVE
        ldx # 3
        lda ARGC_LO
        cmp # 2
        if_eq_then
            from
                lda ARGV_1_LO
                sta ZP_23
                lda ARGV_1_HI
                sta ZP_24
                ldy # 0
            loop
                lda [ZP_23],y
                beq _end                                    ; break
                sta DIR_NAME_DOLLAR,x
            next
                iny
                inx
                bne _loop                                   ; bra
            end

            jmp _end
        else
            cmp # 1
            if_ne_then
                pla
                jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
                rts
            else_end

            lda # PETSCII_ASTERISK
            sta DIR_NAME_DOLLAR,x
            inx
        end

        txa                                                 ; A = DIR_NAME_DOLLAR.LENGTH
        ldx # <DIR_NAME_DOLLAR
        ldy # >DIR_NAME_DOLLAR
        jsr KERNAL_SETNAM
    pla                                                     ; A = DA , STACK = ...
    pha                                                     ; A = DA , STACK = [DA]...
        tax
        lda # FILE_FA
        ldy # 0
        jsr KERNAL_SETLFS
        jsr KERNAL_OPEN
        if_cs_then
            pla
            jsr ERROR_DEVICE_NOT_PRESENT
            rts
        else_end
    pla                                                     ; A = DA , STACK = ...
    jsr PROCESS_DISK_STATUS
    if_cs_then
        lda # FILE_FA
        jsr KERNAL_CLOSE
        jsr RESET_FILE_IO
        rts
    else_end

    jsr PROC_B
    ldx # FILE_FA
    jsr KERNAL_CHKIN
    jsr KERNAL_CHRIN
    jsr KERNAL_CHRIN
    lda # PETSCII_RETURN
    jsr PROC_C
    ; Clear serial status
    lda # KERNAL_OK                                     ; 0
    sta SAVE_KERNAL_READST

    from_loop OUTER
        jsr IN_BYTE
        bcs _end                                        ; break
        jsr IN_BYTE
        bcs _end                                        ; break
        jsr IN_BYTE
        bcs _end                                        ; break
        pha
            jsr IN_BYTE
            tay
        pla
        tax
        jsr BINARY_TO_DECIMAL

        from
            ldx # 0
        loop
            lda BINARY_TO_DECIMAL_DECIMAL,x
            cmp # PETSCII_SPACE
            beq _end                                        ; break
            jsr PROC_C
        next
            inx
            cpx # 3
            bne _loop
        end

        lda # PETSCII_SPACE
        jsr PROC_C

        from_loop
            jsr IN_BYTE
            bcs OUTER::_end                                 ; break OUTER
            cmp # PETSCII_NUL
            beq _end                                        ; break
            jsr PROC_C
        next
            jmp _loop
        end

        lda # PETSCII_RETURN
        jsr PROC_C

        ; Pause on SHIFT
        from_loop
            lda ZPKERNAL_SFDX                               ; $CB Matrix code of key currently being pressed. Values: $00-$3F: Keyboard matrix code. $40: No key is currently pressed. 
            eor # $40
            ora KVAR_SHFLAG                                 ; $028D Shift key indicator. Bits: Bit #0: 1 = One or more of left Shift, right Shift or Shift Lock is currently being pressed or locked. Bit #1: 1 = Commodore is currently being pressed. Bit #2: 1 = Control is currently being pressed.
        next
            bne _loop
        end

    next
        jmp _loop
    end

    lda # PETSCII_RETURN
    jsr PROC_C
    lda # FILE_FA
    jsr KERNAL_CLOSE
    jsr RESET_FILE_IO
    rts
.endproc

;;; summary: Unsigned binary X#Y to decimal (max 9999)
.proc BINARY_TO_DECIMAL
    stx BINARY_TO_DECIMAL_BINARY_LO
    sty BINARY_TO_DECIMAL_BINARY_HI

    from
        ldx # 3
        lda # PETSCII_SPACE
    loop
        sta BINARY_TO_DECIMAL_DECIMAL,x
    next
        dex
        bpl _loop
    end

    from OUTER
        ldx # 0
        ldy # 3
    loop                                                    ; L12C8:

        from INNER
            lda # 0
            sta BINARY_TO_DECIMAL_DECIMAL_DIGIT
        loop
            sec
            lda BINARY_TO_DECIMAL_BINARY_LO
            sbc TABLE_BINARY_TO_DECIMAL_LO,y
            sta BINARY_TO_DECIMAL_TMP
            lda BINARY_TO_DECIMAL_BINARY_HI
            sbc TABLE_BINARY_TO_DECIMAL_HI,y
            bcc _end                                        ; break
            sta BINARY_TO_DECIMAL_BINARY_HI
            lda BINARY_TO_DECIMAL_TMP
            sta BINARY_TO_DECIMAL_BINARY_LO
        next
            inc BINARY_TO_DECIMAL_DECIMAL_DIGIT
            bne _loop                                       ; bra
        end

        if
            lda BINARY_TO_DECIMAL_DECIMAL_DIGIT
            bne _then
            cpx # 0
            beq _end
        then
            clc
            adc # PETSCII_DIGIT_ZERO
            sta BINARY_TO_DECIMAL_DECIMAL,x
            inx
        end

    next
        dey
        bpl _loop                                           ; L12C8
    end

    txa
    if_eq_then
        lda # PETSCII_DIGIT_ZERO
        sta BINARY_TO_DECIMAL_DECIMAL
    else_end

    rts
.endproc

;;; summary: Read byte, checking status
;;; out:
;;;   A: Byte read, if OK
;;;   C: 0=OK 1=FAIL
;;;   SAVE_KERNAL_READST: Last status
.proc IN_BYTE
    lda SAVE_KERNAL_READST
    cmp # KERNAL_OK
    if_ne_then
        sec                                                 ; FAIL
        rts
    else_end

    jsr KERNAL_CHRIN
    pha
        jsr KERNAL_READST
        sta SAVE_KERNAL_READST
    pla
    clc                                                     ; OK
    rts
.endproc

;;; summary: Send command to work disk
;;; changed: ZP_23#ZP_24
.proc CMD_DISK
    lda ARGC_LO
    cmp # 2
    if_ne_then
        jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
        rts
    else_end

    lda ARGV_1_LO
    sta ZP_23
    lda ARGV_1_HI
    sta ZP_24
    lda # DISK_COMMAND_FA                                   ; DISK_COMMAND_FA = DISK_COMMAND_SA
    ldx WORK_DEVICE
    tay
    jsr KERNAL_SETLFS
    lda # 0                                                 ; No name
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    ldx # DISK_COMMAND_FA
    jsr KERNAL_CHKOUT

    from
        ldy # 0
    loop
        lda [ZP_23],y
        beq _end
        jsr KERNAL_CHROUT
    next
        iny
        bne _loop
    end

    lda # PETSCII_RETURN
    jsr KERNAL_CHROUT
    lda WORK_DEVICE
    jsr PROCESS_DISK_STATUS
    jsr RESET_FILE_IO
    rts
.endproc

;;; summary: Delete file
.proc CMD_RM
    lda ARGC_LO
    cmp # 2
    if_ne_then
        jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
        rts
    else_end
    
    clc
    lda WORK_DRIVE
    adc # PETSCII_DIGIT_ZERO
    sta RM_TEXT_DRIVE

    from
        lda ARGV_1_LO
        sta ZP_23
        lda ARGV_1_HI
        sta ZP_24
        ldx # RM_TEXT_OFFSET_NAME
        ldy # 0
    loop
        lda [ZP_23],y
        beq _end                                            ; break
        sta RM_TEXT,x
    next
        iny
        inx
        bne _loop                                           ; bra
    end

    lda # PETSCII_RETURN
    sta RM_TEXT,x
    inx
    txa
    ldx # <RM_TEXT
    ldy # >RM_TEXT
    jsr KERNAL_SETNAM
    lda # DISK_COMMAND_FA                                   ; DISK_COMMAND_FA = DISK_COMMAND_SA
    tay
    ldx WORK_DEVICE
    jsr KERNAL_SETLFS
    jsr KERNAL_OPEN
    if_cs_then
        jsr ERROR_DEVICE_NOT_PRESENT
        rts
    else_end

    lda WORK_DEVICE
    jsr PROCESS_DISK_STATUS
    jsr RESET_FILE_IO
    rts
.endproc

.proc CMD_MV
    lda ARGC_LO
    cmp # 3
    if_ne_then
        jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
        rts
    else_end

    clc
    lda WORK_DRIVE
    adc # PETSCII_DIGIT_ZERO
    sta MV_TEXT_DRIVE

    pha
        from
            lda ARGV_2_LO
            sta ZP_23
            lda ARGV_2_HI
            sta ZP_24
            ldx # 3
            ldy # 0
        loop
            lda [ZP_23],y
            beq _end                                        ; break
            sta MV_TEXT,x
            iny
            inx
            bne _loop                                       ; bra
        end

        lda # PETSCII_EQUALS_SIGN
        sta MV_TEXT,x
        inx
    pla
    sta MV_TEXT,x
    inx
    lda # PETSCII_COLON
    sta MV_TEXT,x
    inx
    from
        lda ARGV_1_LO
        sta ZP_23
        lda ARGV_1_HI
        sta ZP_24
        ldy # 0
    loop
        lda [ZP_23],y
        beq _end                                            ; break
        sta MV_TEXT,x
    next
        iny
        inx
        bne _loop
    end

    lda # PETSCII_RETURN
    sta MV_TEXT,x
    inx
    txa
    ldx # <MV_TEXT
    ldy # >MV_TEXT
    jsr KERNAL_SETNAM
    lda # DISK_COMMAND_FA                                   ; DISK_COMMAND_FA = DISK_COMMAND_SA
    tay
    ldx WORK_DEVICE
    jsr KERNAL_SETLFS
    jsr KERNAL_OPEN
    if_cs_then
        jsr ERROR_DEVICE_NOT_PRESENT
        rts
    else_end

    lda WORK_DEVICE
    jsr PROCESS_DISK_STATUS
    jsr RESET_FILE_IO
    rts
.endproc

.proc CMD_PR
    lda ARGC_LO
    cmp # 2
    if_ne_then
        jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
        rts
    else_end

    from
        lda ARGV_1_LO
        sta ZP_23
        lda ARGV_1_HI
        sta ZP_24
        ldy # 0
    loop
        lda [ZP_23],y
        beq _end                                            ; break
    next
        iny
        bne _loop                                           ; bra
    end

    tya
    ldx ZP_23
    ldy ZP_24
    jsr KERNAL_SETNAM
    lda # FILE_FA
    ldx WORK_DEVICE
    tay
    jsr KERNAL_SETLFS
    jsr KERNAL_OPEN
    if_cs_then
        jsr ERROR_DEVICE_NOT_PRESENT
        rts
    else_end

    lda WORK_DEVICE
    jsr PROCESS_DISK_STATUS
    if_cs_then
        lda # FILE_FA
        jsr KERNAL_CLOSE
        jsr RESET_FILE_IO
        rts
    else_end

    jsr PROC_B
    ldx # FILE_FA
    jsr KERNAL_CHKIN

    from_loop
        jsr KERNAL_CHRIN
        tax
        jsr KERNAL_READST
        pha
            txa
            jsr PROC_C
        pla
    next
        beq _loop
    end

    jsr PROC_D
    lda # FILE_FA
    jsr KERNAL_CLOSE
    jsr RESET_FILE_IO
    rts
.endproc

;;; summary: Error device not present
.proc ERROR_DEVICE_NOT_PRESENT
    lda # FILE_FA
    jsr KERNAL_CLOSE
    ldx # <RESOURCE_STRING_DEVICE_NOT_PRESENT
    ldy # >RESOURCE_STRING_DEVICE_NOT_PRESENT
    jsr OUT_STRING
    jsr RESET_FILE_IO
    rts
.endproc

;;;summary: Show or change work disk
.proc CMD_WORK
    lda ARGC_LO
    cmp # 1
    if_eq_then
        ; Show
        ldx WORK_DEVICE
        ldy WORK_DRIVE
        jsr OUT_DEVICE_DRIVE
        rts
    else_end

    cmp # 3
    if_ne_then
        jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
        rts
    else_end

    ; Change
    jsr CHANGE_DEVICE_DRIVE
    if_cc_then
        ; Change went OK
        stx WORK_DEVICE
        sty WORK_DRIVE
    else_end

    jsr RESET_FILE_IO

    rts
.endproc

;;;summary: Show or change system disk
.proc CMD_SYS
    lda ARGC_LO
    cmp # 1
    if_eq_then
        ; Show
        ldx SYS_DEVICE
        ldy SYS_DRIVE
        jsr OUT_DEVICE_DRIVE
        rts
    else_end

    cmp # 3
    if_ne_then
        jsr ERROR_WRONG_NUMBER_OF_ARGUMENTS
        rts
    else_end

    ; Change
    jsr CHANGE_DEVICE_DRIVE
    if_cc_then
        ; Change went OK
        stx SYS_DEVICE
        sty SYS_DRIVE
    else_end

    jsr RESET_FILE_IO

    rts
.endproc

;;; summary: Error wrong number of arguments
.proc ERROR_WRONG_NUMBER_OF_ARGUMENTS
    ldx # <RESOURCE_STRING_WRONG_NUMBER_OF_ARGUMENTS
    ldy # >RESOURCE_STRING_WRONG_NUMBER_OF_ARGUMENTS
    jsr OUT_STRING
    jsr RESET_FILE_IO
    rts
.endproc

;;; summary: Print device number in `X` (could be 8-30, so need 1 or 2 positions) and drive number in `Y' (0 or 1), and reset file I/O.
;;; in:
;;;   X: Device
;;;   Y: Drive
.proc OUT_DEVICE_DRIVE
    lda # PETSCII_SPACE
    sta STRING_DEVICE_NUMBER_1
    txa
    ldx # 0
    cmp # 10
    if_ge_then
        pha
            lda # PETSCII_DIGIT_ONE
            sta STRING_DEVICE_NUMBER_0
        pla
        sec
        sbc # 10
        inx
    else_end

    clc
    adc # PETSCII_DIGIT_ZERO
    sta STRING_DEVICE_NUMBER_0,x
    clc
    tya
    adc # PETSCII_DIGIT_ZERO
    sta STRING_DRIVE_NUMBER_0
    ldx # <STRING_DEVICE
    ldy # >STRING_DEVICE
    jsr OUT_STRING
    jsr RESET_FILE_IO
    rts
.endproc

;;; summary: Get device and drive number from string at ARGV_1 and ensure device is present.
;;; in:
;;;   ARGV_1: String
;;; out:
;;;   X:  Device number: 8,...,19
;;;   Y:  Drive number: 0 or 1
;;;   C: 0=OK 1=FAIL
;;; changed:
;;;   A+ X+ Y+ ZP_23#ZP_24 STRING_DEVICE_NUMBER_0 STRING_DRIVE_NUMBER_0
;;; notes:
;;;   We test only if the device is present, not the drive.
;;;   This is because it is not possible to test if a drive is present (without a readable disk being present).
.proc CHANGE_DEVICE_DRIVE
    try
        ; Get device number from ARGV[1] into STRING_DEVICE_NUMBER_0
        lda ARGV_1_LO
        sta ZP_23
        lda ARGV_1_HI
        sta ZP_24
        ldx # 0
        ldy # 0
        lda [ZP_23],y
        cmp # PETSCII_DIGIT_ONE
        if_eq_then
            ; A = "1"
            ldx # 10
            iny
            lda [ZP_23],y
            if_eq_then
                ; Device "1" is not possible -> error
                jmp _catch                                  ; throw
            else_end
        else_end

        ; A != "1"
        txa
        clc
        adc [ZP_23],y
        sec
        sbc # PETSCII_DIGIT_ZERO
        ; A: Device number (8,9,10,...,19)
        sta STRING_DEVICE_NUMBER_0                  ; Weird

        iny
        lda [ZP_23],y
        if_ne_then
            ; Another character -> error
            jmp _catch                                  ; throw
        else_end

        ; Get drive number from ARGV[1] into STRING_DRIVE_NUMBER_0
        lda ARGV_2_LO
        sta ZP_23
        lda ARGV_2_HI
        sta ZP_24

        ldy # 0
        lda [ZP_23],y
        cmp # PETSCII_DIGIT_ZERO
        if
            bcc _then                                       ; A < "0" -> error
            cmp # PETSCII_DIGIT_TWO
            bcc _end                                       ; A < "2" -> ok
        then
            ; A < "0" || A >= "2"
        else
            jmp _catch
        end

        tax
        iny
        lda [ZP_23],y
        if_ne_then
            ; Another character -> error
            jmp _catch
        else_end

        ; X: drive number as character "0" or "1"
        txa
        sec
        sbc # PETSCII_DIGIT_ZERO
        ; A: drive number
        sta STRING_DRIVE_NUMBER_0                           ; Weird

        ; STRING_DEVICE_NUMBER_0: Device number
        ; STRING_DRIVE_NUMBER_0: Drive number
        ; Test if device present by sending Memory Read command
        lda # DISK_COMMAND_FA                           ; DISK_COMMAND_FA = DISK_COMMAND_SA
        ldx STRING_DEVICE_NUMBER_0
        tay
        jsr KERNAL_SETLFS
        ldx # <MR_TEXT
        ldy # >MR_TEXT
        lda # MR_TEXT_LENGTH
        jsr KERNAL_SETNAM
        jsr KERNAL_OPEN
        php
            lda # DISK_COMMAND_FA
            jsr KERNAL_CLOSE
        plp
        bcs _catch                                          ; Device not present -> rethrow

        ; C=0 -> Device is present
        ldx STRING_DEVICE_NUMBER_0
        ldy STRING_DRIVE_NUMBER_0
        ; C=0 OK
        rts
    catch
        ldx # <RESOURCE_STRING_DRIVE_NOT_PRESENT
        ldy # >RESOURCE_STRING_DRIVE_NOT_PRESENT
        jsr OUT_STRING
        sec                                                 ; FAIL
    finally_end

    rts
.endproc
